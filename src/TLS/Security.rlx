
#Require "./src/AES/Constructions.rlx"
#Require "./src/SHA2.rlx"
#Require "./src/PKCS5.rlx"
#Require "./src/EC/RFC7748.rlx"

#Require "./src/ASN1/PKCS8.rlx"

namespace TLS::Security {
    enum PseudoRandomFunctionName {
        TLS_1_2_SHA2_256_HMAC
    }

    enum BulkCipherName {
        Null,
        RC4,
        TRIPLE_DES,
        AES_128_GCM,
        AES_128_CBC
    }

    enum CipherType {
        Stream,
        Block,
        AEAD
    }

    enum MACAlgorithmName {
        Null,
        MD5,
        SHA1,
        SHA2_256,
        SHA2_384,
        SHA2_512
    }

    namespace PKCS1_5 {
        enum MessageType As i8 {
            DigestInfo := 0x01
        }

        struct Message {
            i8 Zero
            MessageType Type
        }
    }

    class RSACertificate implements ICertificate, derives INew {
        ASN1::PKCS8::RSAPrivateKey* PrivateKey
        ASN1::X509::Certificate* Certificate
        SHA2_256* Hash

        i32 PublicKeySize

        void* CertificateData
        i32 CertificateDataSize

        define void New(ASN1::PKCS8::RSAPrivateKey* PrivateKey, ASN1::X509::Certificate* Certificate, void* CertificateData, i32 CertificateDataSize) {
            this->PrivateKey := PrivateKey
            this->Certificate := Certificate
            this->CertificateData := CertificateData
            this->CertificateDataSize := CertificateDataSize

            this->PublicKeySize := this->PrivateKey->Modulus->BitCount() / 8

            this->Hash := new SHA2_256()
        }

        define void* GetCertificateData(i32* OutSize) {
            *OutSize := this->CertificateDataSize
            return this->CertificateData
        }

        define void* GetPublicKey(i32* OutSize) {
            *OutSize := this->PublicKeySize

            void* Key := Alloc(*OutSize)

            for (i32 Index := 0, Index < this->PublicKeySize, Index++) {
                (Key As i8*)[Index] := this->PrivateKey->Modulus->GetByte(Index) As i8
            }

            return Key
        }

        define void* Sign(void* Data, i32 DataSize, i32* OutSignatureSize) {
            void* Message := Alloc(this->PublicKeySize)
            i8* MessageBytes := Message As i8*

            i8* DigestInfoDER := i8[
                0x30, 0x31, ; SEQUENCE (DigestInfo)
                    0x30, 0x0d, ; SEQUENCE (AlgorithmIdentifier)
                        ; OID for SHA-256
                        0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
                        0x05, 0x00, ; NULL
                    0x04, 0x20 ; OCTET STRING of length 32
            ]

            PKCS1_5::Message* Header := Message
            Header->Type := PKCS1_5::MessageType::DigestInfo


            i32 PaddingNeeded := this->PublicKeySize - 3 - 19 - 32
            i8* Tail := MessageBytes + 2

            for (i32 Index := 0, Index < PaddingNeeded, Index++) {
                Tail[Index] := 0xFF As i8
            }

            Tail += PaddingNeeded + 1

            MoveMemory(Tail, DigestInfoDER, 19)
            Tail += 19

            this->Hash->Prepare()
            this->Hash->Update(Data, DataSize)
            this->Hash->Finalize(Tail)

            Print("Data Hash:\n%hexdump\n", Tail, 32)

            for (i32 Index := 0, Index < this->PublicKeySize / 2, Index++) {
                i8 Temp := MessageBytes[Index]
                MessageBytes[Index] := MessageBytes[this->PublicKeySize - Index - 1]
                MessageBytes[this->PublicKeySize - Index - 1] := Temp
            }

            BigInteger* MessageInteger := BigInteger:FromBytes(MessageBytes, this->PublicKeySize)

            Print("Message to sign:\n%hexdump\n", Message, this->PublicKeySize)
            Print("Message Integer: %bn-base-16\n", MessageInteger)

            BigInteger* Signature := this->PrivateKey->Encrypt(MessageInteger)

            Print("Signature Integer: %bn-base-16\n", Signature)

            BigInteger* Decrypted := Signature->Reference()->Power(
                this->PrivateKey->PublicExponent->Reference(),
                this->PrivateKey->Modulus->Reference()
            )

            Print("Decrypted Integer: %bn-base-16\n", Decrypted)

            *OutSignatureSize := this->PublicKeySize

            void* SignatureBytes := Alloc(*OutSignatureSize)

            for (i32 Index := 0, Index < *OutSignatureSize, Index++) {
                (SignatureBytes As i8*)[Index] := Signature->GetByte(*OutSignatureSize - Index - 1) As i8
            }

            return SignatureBytes
        }


    }

    struct DirectionalKeySet {
        void* Random
        void* PublicKey
        i32 PublicKeyLength
        void* MACKey
        void* EncryptionKey
        void* IV
    }

    enum ConnectionRole {
        Client,
        Server
    }
    
    class SecurityParameters derives INew {
        ConnectionRole Role
        HandshakeProtocol::ServerHelloHelper* ServerHello
        ;HandshakeProtocol::ServerKeyExchangeHelper* ServerKeyExchange

        DirectionalKeySet Client
        DirectionalKeySet Server

        DirectionalKeySet* Local
        DirectionalKeySet* Remote

        void* LocalPrivateKey
        ICertificate* Certificate

        void* PreMasterSecret ; MasterSecret derived from this
        void* MasterSecret ; KeyBlock derived from this
        void* KeyBlock ; KeySets point into this

        void* HandshakeHash ; Hash of all handshake messages as of (Server|Client)Finish
        i32 HandshakeHashSize

        define void SetLocalIsClient() {
            this->Role := ConnectionRole::Client
            this->Local := &this->Client
            this->Remote := &this->Server
        }

        define void SetLocalIsServer() {
            this->Role := ConnectionRole::Server
            this->Local := &this->Server
            this->Remote := &this->Client
        }

        define i8 IsClient() {
            return this->Role = ConnectionRole::Client
        }

        define i8 IsServer() {
            return this->Role = ConnectionRole::Server
        }
    }

    class TLS_1_2_PRF implements IPseudoRandomFunction, derives INew {
        SecurityParameters* Parameters
        HMACWrapper* HMAC

        define void New(SecurityParameters* Parameters, HMACWrapper* HMAC) {
            this->Parameters := Parameters
            this->HMAC := HMAC
        }

        define void UpdateSeed(i8* Label, void* Seed, i32 SeedSize) {
            this->HMAC->Update(Label, StringLength(Label))
            this->HMAC->Update(Seed, SeedSize)
        }

        define void* Generate(void* Key, i32 Size, i8* Label, void* Seed, i32 SeedSize, i32 NeededBytes) {
            this->HMAC->SetKey(Key, Size)

            i32 BlockSize := this->HMAC->OutputSize

            i32 Iterations := NeededBytes / BlockSize

            if (NeededBytes % BlockSize) {
                Iterations += 1
            }

            ;Print("PRF Request '%s' of %i bytes (%i iterations of %i bytes)\n", Label, NeededBytes, Iterations, BlockSize)
            ;Print("Client Random:\n%hexdump\n", this->Parameters~>Client->Random, 32)
            ;Print("Server Random:\n%hexdump\n", this->Parameters~>Server->Random, 32)

            ; First, generate A(1) from the seed, and then A(N) from A(N-1)
            void* Buffer := Alloc(Iterations * BlockSize)

            this->HMAC->Prepare()
            this->UpdateSeed(Label, Seed, SeedSize)
            this->HMAC->Finalize(Buffer)

            for (i32 Index := 1, Index < Iterations, Index++) {
                void* Previous := Buffer + ((Index - 1) * BlockSize)
                void* AN := Previous + BlockSize

                this->HMAC->Prepare()
                this->HMAC->Update(Previous, BlockSize)
                this->HMAC->Finalize(AN)
            }

            ; Use A(N) plus the seed to generate the output blocks

            for (i32 Index := 0, Index < Iterations, Index++) {
                void* Block := Buffer + (Index * BlockSize)

                this->HMAC->Prepare()
                this->HMAC->Update(Block, BlockSize)
                this->UpdateSeed(Label, Seed, SeedSize)
                this->HMAC->Finalize(Block)
            }

            return Buffer
        }

        define void* GenerateMasterSecret(void* Key, i32 Size, i8* Label, i32 NeededBytes) {
            i8[64] Seed
            MoveMemory(Seed, this->Parameters~>Client->Random, 32)
            MoveMemory(Seed + 32, this->Parameters~>Server->Random, 32)

            return this->Generate(Key, Size, Label, Seed, 64, NeededBytes)
        }
        define void* GenerateKeyMaterial(void* Key, i32 Size, i8* Label, i32 NeededBytes) {
            i8[64] Seed
            MoveMemory(Seed, this->Parameters~>Server->Random, 32)
            MoveMemory(Seed + 32, this->Parameters~>Client->Random, 32)

            return this->Generate(Key, Size, Label, Seed, 64, NeededBytes)
        }
    }

    class AES_128_CBC derives INew {
        AES_CBC* AES

        define void New() {
            this->AES := new AES_CBC(AESKeySize::128)
        }

        define i32 CalculateCipherTextSize(void* Data, i32 Length) {
            i32 Remainder := Length % 16

            if (Remainder = 0) {
                return Length
            }

            return Length + (16 - Remainder)
        }

        define void Pad(NetworkPacket* Packet, i32 DataSize) {
            i32 Remainder := DataSize % 16

            if (Remainder = 0) {
                return
            }

            i32 PaddingNeeded := 16 - Remainder

            i8* PadStart := Packet->GetEnd("TLS::EncryptedRecordProtocol::Body")
            Packet->Extend("TLS::EncryptedRecordProtocol::Body", PaddingNeeded)

            PKCS5Pad(PadStart, DataSize, 16)
        }

        define void Encrypt(void* Data, i32 Length, void* Key, void* IV) {
            this->AES->SetKey(Key, IV)

            i32 Remainder := Length % 16

            if (Remainder != 0) {
                i8* PadStart := Data + Length
                i32 PaddingNeeded := 16 - Remainder

                for (i32 Index := 0, Index < PaddingNeeded, Index++) {
                    PadStart[Index] := PaddingNeeded As i8
                }
            }

            this->AES->EncryptBlocks(Data, Length / 16)
        }

        define void Decrypt(void* Data, i32 Length, void* Key, void* IV) {
            this->AES->SetKey(Key, IV)
            this->AES->DecryptBlocks(Data, Length / 16)
        }
    }

    enum CurveType As i8 {
        Named := 0x3
    }

    enum NamedCurve As i16 {
        x25519 := 0x1d
        x448 := 0x1e
    }

    enum ECPointFormat As i8 {
        Uncompressed := 0
    }

    enum SignatureAlgorithm As i16 {
        Invalid := 0x0000
        Ed25519 := 0x0807
        Ed448 := 0x0808
        RSA_PKCS1_SHA256 := 0x0401
        RSA_PKCS1_SHA512 := 0x0601
    }

    
/* 
    class SecurityContext derives INew {
        SecurityParameters* Parameters

        IHashFunction* Hash
        HMACWrapper* HMAC
        IPseudoRandomFunction* PRF
        IBulkCipher* BulkCipher

        void* PublicKey

        void* PreMasterSecret
        void* MasterSecret

        KeySet* Keys

        define void New(SecurityParameters* Parameters) {
            this->Parameters := Parameters

            this->Hash := Parameters->CreateHashInstance()
            this->HMAC := Parameters->CreateHMACInstance()
            this->PRF := Parameters->CreatePseudoRandomFunctionInstance()
            this->BulkCipher := Parameters->CreateBulkCipherInstance()

            this->PublicKey := Alloc(32)
            this->PreMasterSecret := Alloc(32)

            this->Keys := new KeySet()
        }

        define i8* GetPublicKey() {
            return this->PublicKey
        }
        define i8* GetPreMasterSecret() {
            return this->PreMasterSecret
        }

        define void* Bump(void** pData, i32 Size) {
            void* Result := *pData

            *pData += Size

            return Result
        }

        define void DeriveKeys() {
            this->MasterSecret := this->PRF->Generate(this->PreMasterSecret, 32, "master secret", 48)

            Print("PreMasterSecret:\n%hexdump\n", this->PreMasterSecret, 32)
            Print("MasterSecret:\n%hexdump\n", this->MasterSecret, 48)

            i32 Size := 0

            Size += 0
            Size += 16 * 2 ; TODO: Key Size
            Size += 4 * 2 ; TODO: IV Size

            void* KeyMaterial := this->PRF->Generate(this->MasterSecret, 48, "key expansion", Size)

            Print("Key Material:\n%hexdump\n", KeyMaterial, Size)

            DirectionalKeySet* ClientKeys := &this->Keys->Client
            DirectionalKeySet* ServerKeys := &this->Keys->Server

            ClientKeys->MACKey := this->Bump(&KeyMaterial, this->PRF->GetBlockSize())
            ServerKeys->MACKey := this->Bump(&KeyMaterial, this->PRF->GetBlockSize())

            ClientKeys->EncryptionKey := this->Bump(&KeyMaterial, 16) ; TODO: Key Size
            ServerKeys->EncryptionKey := this->Bump(&KeyMaterial, 16) ; TODO: Key Size

            ClientKeys->IV := this->Bump(&KeyMaterial, 4) ; TODO: IV Size
            ServerKeys->IV := this->Bump(&KeyMaterial, 4) ; TODO: IV Size
        }

        define void SetLocalIsClient() {
            this->Keys->SetLocalIsClient()
        }
        define void SetLocalIsServer() {
            this->Keys->SetLocalIsServer()
        }

        define void Encrypt(void* Data, i32 Length, void* Key, void* IV) {
            this->BulkCipher->Encrypt(Data, Length, Key, IV)
        }
        define void Decrypt(void* Data, i32 Length, void* Key, void* IV) {
            this->BulkCipher->Decrypt(Data, Length, Key, IV)
        }
    } */


    
    /* class EncryptedLayer implements INetworkLayer, RecordProtocol::IRecordLayer, derives INew {
        INetworkLayer* Base
        SecurityParameters* Parameters
        ICipherSuite* Suite

        i64 SendSequenceNumber
        i64 ReceiveSequenceNumber

        RecordProtocol::ProtocolVersion Version

        define void SetVersion(VersionNumber Version) {
            this~>Version->Major := Version.Major()
            this~>Version->Minor := Version.Minor()
        }

        i32 JoinNextPackets
        NetworkPacket* Current

        define void JoinNext(i32 Count) {
            this->JoinNextPackets := Count
            this->Current := this->Base->Enter(null)
        }

        define void New(INetworkLayer* Base) {
            this->Base := Base
        }

        define void EnableEncryption(SecurityParameters* Parameters, ICipherSuite* Suite) {
            this->Parameters := Parameters
            this->Suite := Suite
        }

        define NetworkPacket* Enter(INetworkOptions* RawOptions) {
            RecordProtocol::LayerOptions* Options := RawOptions

            NetworkPacket* Packet := this->Current

            if (this->JoinNextPackets) {
                Packet->ClearMarkers()

                this->JoinNextPackets -= 1
            }
            else {
                Packet := this->Base->Enter(Options)
            }

            RecordProtocol::RecordHeader* Header := Packet->Mark("TLS::RecordProtocol::Record", #RecordProtocol::RecordHeader)
            
            MoveMemory(Header~>Version, this~>Version, #RecordProtocol::ProtocolVersion)
            Header->Type := Options->Type

            if (Options->EnableEncryption) {
                if (this->Suite = null) {
                    Print("No cipher suite selected for encrypted layer\n")
                    Exit(1)
                }

                Packet->Mark("TLS::EncryptedRecordProtocol::Body", this->Suite->CalculateLeadingCipherTextSize())
            }

            return Packet
        }

        define void Leave(NetworkPacket* Packet) {
            if (Packet->Find("TLS::EncryptedRecordProtocol::Body")) {
                ; Packet wants encryption

                i32 LeadingSize := this->Suite->CalculateLeadingCipherTextSize()

                void* Data := Packet->Get("TLS::EncryptedRecordProtocol::Body")
                i32 Size := Packet->Tell() - Packet->GetOffset("TLS::EncryptedRecordProtocol::Body") - LeadingSize

                Print("Leaving Encrypted Layer with %i bytes of body data\n", Size)

                i32 FollowingSize := this->Suite->CalculateFollowingCipherTextSize(Data, Size)

                if (FollowingSize) {
                    Packet->Bump(FollowingSize)
                }

                Packet->Find("TLS::EncryptedRecordProtocol::Body")->Size := LeadingSize + Size + FollowingSize

                Print("    %i bytes of total ciphertext\n", Packet->GetSize("TLS::EncryptedRecordProtocol::Body"))
            }            
            
            RecordProtocol::RecordHeader* Header := Packet->Get("TLS::RecordProtocol::Record")
            i32 HeaderEndOffset := Packet->GetEndOffset("TLS::RecordProtocol::Record")

            Print("Send record of length: %i\n", Packet->Offset - HeaderEndOffset)

            Header->Length := Swap16((Packet->Offset - HeaderEndOffset) As i16)

            Packet->End()

            if (Packet->Find("TLS::EncryptedRecordProtocol::Body")) {
                AuthenticatedData Authenticate {
                    SequenceNumber: Swap64(this->SendSequenceNumber),
                    Type: Header->Type,
                    Version: {
                        Major: this->Version->Major,
                        Minor: this->Version->Minor
                    },
                    Length: Header->Length
                }

                this->Suite->Encrypt(
                    Data, Size,
                    &Authenticate, #AuthenticatedData,
                    this->Parameters->Local->EncryptionKey, this->Parameters->Local->IV
                )
            }

            Print("Joining next %i packets\n", this->JoinNextPackets)

            if !(this->JoinNextPackets) {
                this->Base->Leave(Packet)
            }
        }

        define void Process(NetworkPacket* Packet) {
            
        }
    } */
}