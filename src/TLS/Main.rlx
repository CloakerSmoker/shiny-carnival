
#Require "$/Console.rlx"
#Require "$/Debug.rlx"

#Require "./src/TLS/Core.rlx"

#Require "./src/TLS/RecordProtocol.rlx"
#Require "./src/TLS/HandshakeProtocol.rlx"
#Require "./src/TLS/Security.rlx"

#Require "./src/network/Socket.rlx"

#Require "./src/EC/RFC7748.rlx"

#Require "./src/SHA2.rlx"
#Require "./src/HMAC.rlx"

i64 DevURandom := FileOpen("/dev/urandom", FILE_READ)

define void SecureFillRandom(void* Buffer, i32 Count) {
    FileRead(DevURandom, Buffer, Count)
}

define void* AllocateSecureRandom(i32 Size) {
    void* Result := Alloc(Size)
    SecureFillRandom(Result, Size)
    return Result
}

/*
define NetworkPacket* ClientHello() {
    ClientHelloLayer->SetRandom("thirty two bytes of random data.")
    ClientHelloLayer->AddCipherSuite(TLS::CipherSuite::TLS_RSA_WITH_AES_128_GCM_SHA256)
    ClientHelloLayer->AddCompressionMethod(TLS::HandshakeProtocol::CompressionMethod::Null)

    NetworkPacket* Packet := ClientHelloLayer->Enter(null)

    ClientHelloLayer->Leave(Packet)

    return Packet
}

define NetworkPacket* ServerHello() {
    ServerHelloLayer->SetRandom("thirty two bytes of random data.")
    ServerHelloLayer->SetCipherSuite(TLS::CipherSuite::TLS_RSA_WITH_AES_128_GCM_SHA256)
    ServerHelloLayer->SetCompressionMethod(TLS::HandshakeProtocol::CompressionMethod::Null)

    NetworkPacket* Packet := ServerHelloLayer->Enter(null)

    ServerHelloLayer->Leave(Packet)

    return Packet
}
*/

class Plumbing derives INew {
    INetworkLayer* Base

    TLS::RecordProtocol::Layer* RecordLayer
    TLS::HandshakeProtocol::Layer* HandshakeLayer
    
    define void RegisterContentType(TLS::RecordProtocol::ContentType Type, INetworkLayer* Layer) {
        this->RecordLayer->RegisterContentType(Type, Layer)
    }
    define void RegisterMessageType(TLS::HandshakeProtocol::MessageType Type, INetworkLayer* Layer) {
        this->HandshakeLayer->RegisterMessageType(Type, Layer)
    }

    define void New(INetworkLayer* Base) {
        this->Base := Base

        this->RecordLayer := new TLS::RecordProtocol::Layer(Base)
        this->RecordLayer->SetVersion(TLS::VersionNumber::TLS_1_0)

        this->HandshakeLayer := new TLS::HandshakeProtocol::Layer(this->RecordLayer)
        this->RegisterContentType(TLS::RecordProtocol::ContentType::Handshake, this->HandshakeLayer)

        /*this->ClientHelloLayer := new TLS::HandshakeProtocol::ClientHelloLayer(this->HandshakeLayer)
        this->HandshakeLayer->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ClientHello, this->ClientHelloLayer)

        this->ServerHelloLayer := new TLS::HandshakeProtocol::ServerHelloLayer(this->HandshakeLayer)
        this->HandshakeLayer->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerHello, this->ServerHelloLayer)*/
    }
}

enum ClientState {
    ConnectionOffered
    ServerAccepted
    KeyExchangeNeeded

}

class CallbackNetworkLayer implements INetworkLayer, derives INew {
    void* State
    void(void*, NetworkPacket*) Callback

    define void New(void* State, void(void*, NetworkPacket*) Callback) {
        this->State := State
        this->Callback := Callback
    }

    define NetworkPacket* Enter(INetworkOptions* Options) {
        return null
    }
    define void Leave(NetworkPacket* Packet) {
    }

    define void Process(NetworkPacket* Packet) {
        this->Callback(this->State, Packet)
    }
}





class Client derives INew {
    ClientState State

    SocketNetworkLayer* Transport
    Plumbing* Base

    TLS::Security::SecurityParameters* Security
    TLS::Security::ICipherSuite* CipherSuite

    TLS::HandshakeProtocol::ClientHelloHelper* ClientHello

    CallbackNetworkLayer* OnHandshakeCallback

    TLS::HandshakeProtocol::ServerHelloHelper* ServerHello
    ;TLS::HandshakeProtocol::CertificateHelper* Certificate
    TLS::HandshakeProtocol::ServerKeyExchangeHelper* ServerKeyExchange

    define CallbackNetworkLayer* MakeCallback(void(void*, NetworkPacket*) Method) {
        return new CallbackNetworkLayer(this, Method)
    }

    define void OnChangeCipherSpec(NetworkPacket* Packet) {
        Print("Received ChangeCipherSpec\n")

        this->Base->RecordLayer->EnableRemoteEncryption()
    }

    define void SendClientHello() {
        this->State := ClientState::ConnectionOffered

        NetworkPacket* Packet := this->Base->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::ClientHello)

        this->ClientHello->Write(Packet)

        this->Base->HandshakeLayer->Leave(Packet)
    }

    void* PrivateKey

    define void SendClientKeyExchange() {
        NetworkPacket* Packet := this->Base->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::ClientKeyExchange)

        MoveMemory(Packet->Bump(1), i8[32], 1)
        MoveMemory(Packet->Bump(32), this->Security~>Client->PublicKey, 32)

        this->Base->HandshakeLayer->Leave(Packet)
    }

    define void SendChangeCipherSpec() {
        NetworkPacket* Packet := this->Base->RecordLayer->Enter(TLS::RecordProtocol::ContentType::ChangeCipherSpec)

        MoveMemory(Packet->Bump(1), i8[1], 1)

        this->Base->RecordLayer->Leave(Packet)
    }

    define void* CalculateVerifyData(i8* Label, i32 IgnoreHandshakeCount) {
        IHashFunction* Hash := this->CipherSuite->GetHashFunction()

        Hash->Prepare()

        i32 HandshakeCount := this->Base->HandshakeLayer->Messages->Count() - IgnoreHandshakeCount

        for (i32 Index := 0, Index < HandshakeCount, Index++) {
            NetworkPacket* Message := this->Base->HandshakeLayer->Messages->At(Index)

            Print("Handshake Message %i:\n%hexdump\n", Index, Message->Buffer, Message->Size)

            Hash->Update(Message->Buffer, Message->Size)
        }

        HashFunctionInfo Info
        Hash->GetInfo(&Info)

        void* HandshakeHash := Alloc(Info.OutputSize)

        Hash->Finalize(HandshakeHash)

        TLS::Security::IPseudoRandomFunction* PRF := this->CipherSuite->GetPseudoRandomFunction()

        void* VerifyData := PRF->Generate(this->Security->MasterSecret, 48, Label, HandshakeHash, Info.OutputSize, 12)

        Free(HandshakeHash)

        return VerifyData
    }

    define void SendClientHelloDone() {
        NetworkPacket* Packet := this->Base->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::Finished)

        void* VerifyData := this->CalculateVerifyData("client finished", 0)
        MoveMemory(Packet->Bump(12), VerifyData, 12)
        Free(VerifyData)

        this->Base->HandshakeLayer->Leave(Packet)
    }

    define void SendApplicationData(void* Data, i32 Size) {
        NetworkPacket* Packet := this->Base->RecordLayer->Enter(TLS::RecordProtocol::ContentType::ApplicationData)

        MoveMemory(Packet->Bump(Size), Data, Size)

        this->Base->RecordLayer->Leave(Packet)
    }

    define void OnHandshake(NetworkPacket* Packet) {
        TLS::HandshakeProtocol::HandshakeRecord* Record := Packet->Get("TLS::HandshakeProtocol::Record")

        if (Record->Type = TLS::HandshakeProtocol::MessageType::ServerHello) {
            this->Base->RecordLayer->SetVersion(TLS::VersionNumber::TLS_1_2)

            this->ServerHello->Read(Packet)

            auto Parameters := new TLS::Security::SecurityParameters()

            Parameters->SetLocalIsClient()

            Parameters->ServerHello := this->ServerHello

            this->Security := Parameters

            if (this->ServerHello->Cipher = TLS::CipherSuite::ECDH_RSA_WITH_AES_128_SHA256) {
                ; pass
            }
            else if (this->ServerHello->Cipher = TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256) {
                ; pass
            }
            else {
                Print("Unsupported CipherSuite %s (%x)\n", nameof:(this->ServerHello->Cipher), this->ServerHello->Cipher)
                Exit(1)
            }

            Parameters~>Client->Random := this->ClientHello->Random
            Parameters~>Server->Random := this->ServerHello->Random

            Print("Server Random:\n%hexdump\n", this->ServerHello->Random, 32)

            Print("Server selected CipherSuite %s\n", nameof:(this->ServerHello->Cipher))

            i32 Count := this->ServerHello->Extensions->Count()
            Print("Server replied with %i extensions\n", Count)

            for (i32 Index := 0, Index < Count, Index++) {
                TLS::HandshakeProtocol::ExtensionEntry* Entry := this->ServerHello->Extensions->At(Index)

                Print("[%i]: %s (%x bytes)\n", Index, nameof:(Entry->Type), Entry->Length)
            }
        }
        else if (Record->Type = TLS::HandshakeProtocol::MessageType::ServerKeyExchange) {
            this->ServerKeyExchange->Read(Packet)

            Print("Server Curve Type: %s\n", nameof:(this->ServerKeyExchange->Type))
            Print("Server Curve: %s\n", nameof:(this->ServerKeyExchange->Curve))

            Print("Server Public Key:\n%hexdump\n", this->ServerKeyExchange->PublicKey, this->ServerKeyExchange->PublicKeyLength)

            Print("Server Signature Algorithm: %s\n", nameof:(this->ServerKeyExchange->Algorithm))

            ;Print("Server Signature:\n%hexdump\n", this->ServerKeyExchange->Signature, this->ServerKeyExchange->SignatureLength)

            this->Security->ServerKeyExchange := this->ServerKeyExchange
            this->Security~>Server->PublicKey := this->ServerKeyExchange->PublicKey

            this->Security->LocalPrivateKey := "thirty two bytes of random!"

            if (this->ServerHello->Cipher = TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256) {
                this->CipherSuite := new TLS::Security::ECDHE_RSA_WITH_AES_128_GCM_SHA256(this->Security)
            }
            ;else if (this->ServerHello->Cipher = TLS::CipherSuite::ECDH_RSA_WITH_AES_128_SHA256) {
            ;    this->CipherSuite := new TLS::EncryptedRecordProtocol::ECDH_RSA_WITH_AES_128_SHA256(this->SecurityParameters)
            ;}
            else {
                Print("Unsupported CipherSuite %s (%x)\n", nameof:(this->ServerHello->Cipher), this->ServerHello->Cipher)
                Exit(1)
            }
        }
        else if (Record->Type = TLS::HandshakeProtocol::MessageType::ServerHelloDone) {
            this->Base->RecordLayer->JoinNext(3)

            this->SendClientKeyExchange()
            this->SendChangeCipherSpec()

            this->Base->RecordLayer->EnableLocalEncryption(this->Security, this->CipherSuite)

            this->SendClientHelloDone()
        }
        else if (Record->Type = TLS::HandshakeProtocol::MessageType::Finished) {
            Print("Received Finished\n")

            void* CalculatedVerifyData := this->CalculateVerifyData("server finished", 1)
            void* ProvidedVerifyData := Packet->Get("TLS::HandshakeProtocol::Data")

            Print("Expected Verify Data:\n%hexdump\n", CalculatedVerifyData, 12)
            Print("Received Verify Data:\n%hexdump\n", ProvidedVerifyData, 12)

            if (CompareMemory(CalculatedVerifyData, ProvidedVerifyData, 12)) {
                Print("Server Finished verify data matches!\n")
            }
            else {
                Print("Server Finished verify data does not match!\n")
                Exit(1)
            }

            Free(CalculatedVerifyData)

            this->SendApplicationData("GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n", 55)

            ;this->State := ClientState::KeyExchangeNeeded
        }
        else {
            Print("Unhandled handshake message %s (%x)\n", nameof:(Record->Type), Record->Type)
        }
    }

    define void OnApplicationData(NetworkPacket* Packet) {
        TLS::RecordProtocol::RecordHeader* Header := Packet->Get("TLS::RecordProtocol::Record")
        void* Body := (Header As void*) + #TLS::RecordProtocol::RecordHeader
        i32 Size := Header->Length

        *((Body + Size - 16) As i8*) := 0

        Print("Got Application Data: %s", Body + 8)
    }

    define void Wait() {
        Socket Remote := this->Transport->Remote

        Remote->Poll(POLL_FOR_READ, -1)

        void* Buffer := Alloc(1024)
        i32 Size := 0

        loop {
            i32 ChunkSize := Remote->Receive(Buffer + Size, 1024, 0) As i32
            Size += ChunkSize

            if (ChunkSize != 1024) {
                break
            }

            Buffer := ReAlloc(Buffer, Size + 1024)
        }

        NetworkPacket* Packet := new NetworkPacket(Buffer, Size)

        this->Base->RecordLayer->Process(Packet)
    }

    define void New(SocketNetworkLayer* Base) {
        this->Transport := Base
        this->Base := new Plumbing(Base)

        this->ClientHello := new TLS::HandshakeProtocol::ClientHelloHelper(TLS::VersionNumber::TLS_1_2)
        this->ServerHello := new TLS::HandshakeProtocol::ServerHelloHelper()
        this->ServerKeyExchange := new TLS::HandshakeProtocol::ServerKeyExchangeHelper()

        INetworkLayer* OnChangeCipherSpec := this->MakeCallback(&self.OnChangeCipherSpec)

        this->Base->RegisterContentType(TLS::RecordProtocol::ContentType::ChangeCipherSpec, OnChangeCipherSpec)

        INetworkLayer* OnHandshake := this->MakeCallback(&self.OnHandshake)

        this->Base->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerHello, OnHandshake)
        this->Base->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerKeyExchange, OnHandshake)
        this->Base->RegisterMessageType(TLS::HandshakeProtocol::MessageType::Certificate, OnHandshake)
        this->Base->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerHelloDone, OnHandshake)
        this->Base->RegisterMessageType(TLS::HandshakeProtocol::MessageType::Finished, OnHandshake)

        INetworkLayer* OnApplicationData := this->MakeCallback(&self.OnApplicationData)

        this->Base->RegisterContentType(TLS::RecordProtocol::ContentType::ApplicationData, OnApplicationData)
    }
}

#Require "./src/TLS/tests/ServerHello_Cert_Kex_Done.rlx"

define void Main() {
    ;SocketNetworkLayer* Base := new SocketNetworkLayer(new IPV4SocketAddress("24.124.77.9", 443))
    SocketNetworkLayer* Base := new SocketNetworkLayer(new IPV4SocketAddress("127.0.0.1", 4433))
    Client* C := new Client(Base)

    i8[32] RandomBytes
    SecureFillRandom(RandomBytes, 32)

    C->ClientHello->SetRandom(RandomBytes)
    C->ClientHello->AddCipherSuite(TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256)
    ;C->ClientHello->AddCipherSuite(TLS::CipherSuite::RSA_WITH_AES_128_GCM_SHA256)
    C->ClientHello->AddCipherSuite(TLS::CipherSuite::ECDH_RSA_WITH_AES_128_SHA256)
    C->ClientHello->AddCompressionMethod(TLS::HandshakeProtocol::CompressionMethod::Null)

    ;C->ClientHello->AddServerHostName("jellyfin.muscular.top")

    ;C->ClientHello->AddExtension(TLS::HandshakeProtocol::ExtensionType::ExtendedMasterSecret)
    ;C->ClientHello->AddExtension(TLS::HandshakeProtocol::ExtensionType::EncryptThenMAC)

    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::Ed25519)
    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::Ed448)
    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::RSA_PKCS1_SHA256)
    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::RSA_PKCS1_SHA512)

    C->ClientHello->AddSupportedGroup(TLS::HandshakeProtocol::NamedCurve::x25519)
    C->ClientHello->AddSupportedGroup(TLS::HandshakeProtocol::NamedCurve::x448)

    C->ClientHello->AddPointFormat(TLS::HandshakeProtocol::ECPointFormat::Uncompressed)

    

    C->SendClientHello()

    C->Wait()
    C->Wait()
    C->Wait()

    ;C->Poll(-1)

    /*
    Plumbing* P := new Plumbing()

    NetworkPacket* Packet := new NetworkPacket(SERVER_HELLO_TEST_SIZE + 1)
    MoveMemory(Packet->Buffer, SERVER_HELLO_TEST, SERVER_HELLO_TEST_SIZE)

    P->RecordLayer->Process(Packet)

    Packet->DumpMarkers()*/
}