
#Require "$/Console.rlx"
#Require "$/Debug.rlx"

i64 DevURandom := FileOpen("/dev/urandom", FILE_READ)

define void SecureFillRandom(void* Buffer, i32 Count) {
    FileRead(DevURandom, Buffer, Count)
}

define void* AllocateSecureRandom(i32 Size) {
    void* Result := Alloc(Size)
    SecureFillRandom(Result, Size)
    return Result
}

#Require "./src/TLS/Core.rlx"

#Require "./src/TLS/RecordProtocol.rlx"
#Require "./src/TLS/AlertProtocol.rlx"
#Require "./src/TLS/HandshakeProtocol.rlx"
#Require "./src/TLS/Security.rlx"
#Require "./src/TLS/CipherSuites/ECDHE_RSA_WITH_AES_128_GCM_SHA256.rlx"

#Require "./src/network/Socket.rlx"

#Require "./src/EC/RFC7748.rlx"

#Require "./src/SHA2.rlx"
#Require "./src/HMAC.rlx"

/*
define NetworkPacket* ClientHello() {
    ClientHelloLayer->SetRandom("thirty two bytes of random data.")
    ClientHelloLayer->AddCipherSuite(TLS::CipherSuite::TLS_RSA_WITH_AES_128_GCM_SHA256)
    ClientHelloLayer->AddCompressionMethod(TLS::HandshakeProtocol::CompressionMethod::Null)

    NetworkPacket* Packet := ClientHelloLayer->Enter(null)

    ClientHelloLayer->Leave(Packet)

    return Packet
}

define NetworkPacket* ServerHello() {
    ServerHelloLayer->SetRandom("thirty two bytes of random data.")
    ServerHelloLayer->SetCipherSuite(TLS::CipherSuite::TLS_RSA_WITH_AES_128_GCM_SHA256)
    ServerHelloLayer->SetCompressionMethod(TLS::HandshakeProtocol::CompressionMethod::Null)

    NetworkPacket* Packet := ServerHelloLayer->Enter(null)

    ServerHelloLayer->Leave(Packet)

    return Packet
}
*/
/* 
class Plumbing derives INew {
    INetworkLayer* Base

    TLS::RecordProtocol::Layer* RecordLayer
    TLS::HandshakeProtocol::Layer* HandshakeLayer
    
    define void RegisterContentType(TLS::RecordProtocol::ContentType Type, INetworkLayer* Layer) {
        this->RecordLayer->RegisterContentType(Type, Layer)
    }
    define void RegisterMessageType(TLS::HandshakeProtocol::MessageType Type, INetworkLayer* Layer) {
        this->HandshakeLayer->RegisterMessageType(Type, Layer)
    }

    define void New(INetworkLayer* Base) {
        this->Base := Base

        this->RecordLayer := new TLS::RecordProtocol::Layer(Base)
        this->RecordLayer->SetVersion(TLS::VersionNumber::TLS_1_0)

        this->HandshakeLayer := new TLS::HandshakeProtocol::Layer(this->RecordLayer)
        this->RegisterContentType(TLS::RecordProtocol::ContentType::Handshake, this->HandshakeLayer)

        /*this->ClientHelloLayer := new TLS::HandshakeProtocol::ClientHelloLayer(this->HandshakeLayer)
        this->HandshakeLayer->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ClientHello, this->ClientHelloLayer)

        this->ServerHelloLayer := new TLS::HandshakeProtocol::ServerHelloLayer(this->HandshakeLayer)
        this->HandshakeLayer->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerHello, this->ServerHelloLayer)*/
    }
} */

class CallbackNetworkLayer implements INetworkLayer, derives INew {
    void* State
    void(void*, NetworkPacket*) Callback

    define void New(void* State, void(void*, NetworkPacket*) Callback) {
        this->State := State
        this->Callback := Callback
    }

    define NetworkPacket* Enter(INetworkOptions* Options) {
        return null
    }
    define void Leave(NetworkPacket* Packet) {
    }

    define void Process(NetworkPacket* Packet) {
        this->Callback(this->State, Packet)
    }
}

namespace TLS {
    enum ClientState {
        ConnectionOffered ; ServerHello -> ServerAccepted
        ServerAccepted ; Certificate -> ServerSentCertificate
        ServerSentCertificate ; ServerKeyExchange -> ServerKeyExchanged
        ServerKeyExchanged ; ServerHelloDone -> ServerHelloDone
        ServerHelloDone ; ChangeCipherSpec -> ServerChangedCipher
        ServerChangedCipher ; ServerFinished -> Established
        Established ; Application Data, Alert(Warning, CloseNotify) -> Closed
        ClientClosed ; Alert(Warning, CloseNotify) -> Closed
        ; ^ for when the local end initiates a close, and we need to wait for the remote
        ;    to ack it
        Closed ; duh
    }

    class Connection {
        i8 dummy
    }

    enum ServerState {
        AwaitingClientHello ; Initial state, ClientHello -> ClientHelloReceived
        ClientHelloReceived ; ClientKeyExchange -> ClientKeyExchanged
        ClientKeyExchanged ; ChangeCipherSpec -> ClientChangedCipher
        ClientChangedCipher ; ClientFinished -> Established
        Established ; Application Data, Alert(Warning, CloseNotify) -> Closed
        ServerClosed ; Alert(Warning, CloseNotify) -> Closed
        Closed ; duh
    }

    class Server derives INew {
        ServerState State

        Socket Remote

        TLS::Security::ICertificate* SigningCertificate

        TLS::RecordProtocol::Layer* RecordLayer
        TLS::HandshakeProtocol::Layer* HandshakeLayer

        define void RegisterContentType(TLS::RecordProtocol::ContentType Type, INetworkLayer* Layer) {
            this->RecordLayer->RegisterContentType(Type, Layer)
        }
        define void RegisterMessageType(TLS::HandshakeProtocol::MessageType Type, INetworkLayer* Layer) {
            this->HandshakeLayer->RegisterMessageType(Type, Layer)
        }

        TLS::Security::SecurityParameters* Security
        TLS::Security::ICipherSuite* CipherSuite

        TLS::HandshakeProtocol::ClientHelloHelper* ClientHello
        TLS::HandshakeProtocol::ServerHelloHelper* ServerHello
        TLS::HandshakeProtocol::CertificateHelper* Certificates
        ;TLS::HandshakeProtocol::ServerKeyExchangeHelper* ServerKeyExchange

        CallbackNetworkLayer* OnHandshakeCallback

        define CallbackNetworkLayer* MakeCallback(void(void*, NetworkPacket*) Method) {
            return new CallbackNetworkLayer(this, Method)
        }

        define void SendAlert(TLS::AlertLevel Level, TLS::AlertDescription Description) {
            this->RecordLayer->JoinNext(0)

            NetworkPacket* Packet := this->RecordLayer->Enter(TLS::RecordProtocol::ContentType::Alert)

            TLS::AlertRecord* Alert := Packet->Mark("TLS::AlertProtocol::Alert", #TLS::AlertRecord)

            Alert->Level := Level
            Alert->Description := Description

            this->RecordLayer->Leave(Packet)
        }

        define void OnAlert(NetworkPacket* Packet) {
            AlertRecord* Alert := Packet->Mark("TLS::AlertProtocol::Alert", #AlertRecord)

            Print("Received alert at %s level, description %s\n", nameof:(Alert->Level), nameof:(Alert->Description))

            if (Alert->Description = AlertDescription::CloseNotify) {
                this->SendAlert(AlertLevel::Warning, AlertDescription::CloseNotify)
                this->State := ServerState::Closed
            }
            else if (Alert->Level = AlertLevel::Fatal) {
                this->SendAlert(AlertLevel::Warning, AlertDescription::CloseNotify)
                this->State := ServerState::Closed
            }
        }

        define i8 SendServerHello() {
            i8 ValidCompression := false

            i32 Length := this->ClientHello->CompressionMethods->Length

            for (i32 Index := 0, Index < Length, Index++) {
                if (this->ClientHello->CompressionMethods->Methods[Index] = TLS::HandshakeProtocol::CompressionMethod::Null) {
                    ValidCompression := true
                }
            }

            if !(ValidCompression) {
                Print("Client does not support null compression\n")
                this->SendAlert(AlertLevel::Fatal, AlertDescription::HandshakeFailure)
                this->State := ServerState::Closed
                return false
            }

            CipherSuite SelectedSuite := TLS::CipherSuite::Invalid

            Length := this->ClientHello->CipherSuites->Length

            for (i32 Index := 0, Index < Length, Index++) {
                CipherSuite Candidate := this->ClientHello->CipherSuites->Suites[Index]

                Print("Client supports cipher suite %s %x\n", nameof:(Candidate), Candidate)

                if (Candidate = TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256) {
                    SelectedSuite := Candidate
                    break
                }
                else if (Candidate = TLS::CipherSuite::ECDH_RSA_WITH_AES_128_SHA256) {
                    SelectedSuite := Candidate
                    break
                }
            }

            if (this->ClientHello->Extensions->Has(HandshakeProtocol::ExtensionType::RenegotiationInfo)) {
                Print("Client supports secure renegotiation\n")
                
                this->ServerHello->Extensions->Add(
                    TLS::HandshakeProtocol::ExtensionType::RenegotiationInfo,
                    i8[0],
                    1
                )
            }
            else {
                for (i32 Index := 0, Index < Length, Index++) {
                    CipherSuite Suite := this->ClientHello->CipherSuites->Suites[Index]

                    if (Suite = CipherSuite::SECURE_RENEGOTIATION_MARKER) {
                        Print("Client supports secure renegotiation\n")
                        
                        this->ServerHello->Extensions->Add(
                            TLS::HandshakeProtocol::ExtensionType::RenegotiationInfo,
                            i8[0],
                            1
                        )
                    }
                }
            }

            if (SelectedSuite = TLS::CipherSuite::Invalid) {
                Print("Client does not support any known cipher suites\n")
                this->SendAlert(AlertLevel::Fatal, AlertDescription::HandshakeFailure)
                this->State := ServerState::Closed
                return false
            }

            if (SelectedSuite = TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256) {
                this->CipherSuite := new TLS::Security::ECDHE_RSA_WITH_AES_128_GCM_SHA256::Suite(this->Security)
            }

            this->RecordLayer->SetSecurityParameters(this->Security, this->CipherSuite)

            this->Security->Local->Random := AllocateSecureRandom(32)
            MoveMemory(this->ServerHello->Random, this->Security->Local->Random, 32)

            this->ServerHello->Cipher := SelectedSuite
            this->ServerHello->Compression := TLS::HandshakeProtocol::CompressionMethod::Null

            HandshakeProtocol::ExtensionList* ReplyExtensions := this->ServerHello->Extensions

            this->CipherSuite->SendServerExtensions(this->ClientHello->Extensions, ReplyExtensions)

            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::ServerHello)
            this->ServerHello->Write(Packet)
            this->HandshakeLayer->Leave(Packet)

            this->RecordLayer->SetVersion(TLS::VersionNumber::TLS_1_2)

            return true
        }

        define void SendCertificates() {
            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::Certificate)
            this->Certificates->Write(Packet)
            this->HandshakeLayer->Leave(Packet)
        }

        define void SendServerKeyExchange() {
            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::ServerKeyExchange)
            this->CipherSuite->SendServerKeyExchange(Packet)
            this->HandshakeLayer->Leave(Packet)
        }

        define void SendServerHelloDone() {
            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::ServerHelloDone)
            this->HandshakeLayer->Leave(Packet)
        }

        define void* CalculateVerifyData(i8* Label, i32 IgnoreHandshakeCount) {
            IHashFunction* Hash := this->CipherSuite->GetHashFunction()

            Hash->Prepare()

            i32 HandshakeCount := this->HandshakeLayer->Messages->Count() - IgnoreHandshakeCount

            for (i32 Index := 0, Index < HandshakeCount, Index++) {
                NetworkPacket* Message := this->HandshakeLayer->Messages->At(Index)

                ;Print("Handshake Message %i:\n%hexdump\n", Index, Message->Buffer, Message->Size)

                Hash->Update(Message->Buffer, Message->Size)
            }

            HashFunctionInfo Info
            Hash->GetInfo(&Info)

            void* HandshakeHash := Alloc(Info.OutputSize)

            Hash->Finalize(HandshakeHash)

            TLS::Security::IPseudoRandomFunction* PRF := this->CipherSuite->GetPseudoRandomFunction()

            void* VerifyData := PRF->Generate(this->Security->MasterSecret, 48, Label, HandshakeHash, Info.OutputSize, 12)

            Free(HandshakeHash)

            return VerifyData
        }

        define void SendChangeCipherSpec() {
            NetworkPacket* Packet := this->RecordLayer->Enter(TLS::RecordProtocol::ContentType::ChangeCipherSpec)
            MoveMemory(Packet->Bump(1), i8[1], 1)
            this->RecordLayer->Leave(Packet)

            this->RecordLayer->EnableLocalEncryption()
        }

        define void SendServerHandshakeFinished() {
            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::Finished)

            void* VerifyData := this->CalculateVerifyData("server finished", 0)
            MoveMemory(Packet->Bump(12), VerifyData, 12)
            Free(VerifyData)

            this->HandshakeLayer->Leave(Packet)
        }

        define void OnHandshake(NetworkPacket* Packet) {
            TLS::HandshakeProtocol::HandshakeRecord* Record := Packet->Get("TLS::HandshakeProtocol::Record")

            Print("Server received handshake message of type %s\n", nameof:(Record->Type))

            if (Record->Type = TLS::HandshakeProtocol::MessageType::ClientHello) {
                if (this->State != ServerState::AwaitingClientHello) {
                    Print("Unexpected ClientHello\n")
                    Exit(1)
                }

                this->ClientHello->Read(Packet)

                auto Parameters := new TLS::Security::SecurityParameters()

                Parameters->Certificate := this->SigningCertificate
                Parameters->SetLocalIsServer()
                Parameters~>Client->Random := this->ClientHello->Random

                this->Security := Parameters

                Print("Client Random:\n%hexdump\n", this->ClientHello->Random, 32)

                i32 Count := this->ClientHello->Extensions->Count()
                Print("Client sent %i extensions\n", Count)

                for (i32 Index := 0, Index < Count, Index++) {
                    TLS::HandshakeProtocol::ExtensionEntry* Entry := this->ClientHello->Extensions->At(Index)

                    Print("[%i]: %s (%x bytes)\n", Index, nameof:(Entry->Type), Entry->Length)
                }

                this->RecordLayer->JoinNext(4)

                if (this->SendServerHello()) {
                    this->SendCertificates()
                    this->SendServerKeyExchange()
                    this->SendServerHelloDone()
                    this->State := ServerState::ClientHelloReceived
                }
            }
            else if (Record->Type = TLS::HandshakeProtocol::MessageType::ClientKeyExchange) {
                if (this->State != ServerState::ClientHelloReceived) {
                    Print("Unexpected ClientKeyExchange\n")
                    Exit(1)
                }

                try {
                    this->CipherSuite->ReceiveClientKeyExchange(Packet)
                    this->State := ServerState::ClientKeyExchanged
                }
                catch (i64 RawException) {
                    Print("Caught exception processing ClientKeyExchange %x\n", RawException)

                    FatalAlert* Exception := RawException As void*

                    Print("Error processing ClientKeyExchange: %s\n", Exception->Message)
                    this->SendAlert(AlertLevel::Fatal, Exception->Description)
                }
            }
            else if (Record->Type = TLS::HandshakeProtocol::MessageType::Finished) {
                if (this->State != ServerState::ClientChangedCipher) {
                    Print("Unexpected Finished\n")
                    Exit(1)
                }

                void* ExpectedVerifyData := this->CalculateVerifyData("client finished", 1)

                Packet->AssertBound(12)
                void* ReceivedVerifyData := Packet->Bump(12)

                Print("Expected Verify Data:\n%hexdump\n", ExpectedVerifyData, 12)
                Print("Received Verify Data:\n%hexdump\n", ReceivedVerifyData, 12)

                if (CompareMemory(ExpectedVerifyData, ReceivedVerifyData, 12)) {
                    Print("Client Finished verify data matches expected value\n")
                    this->State := ServerState::Established

                    this->SendChangeCipherSpec()
                    this->SendServerHandshakeFinished()
                }
                else {
                    Print("Client Finished verify data does not match expected value\n")
                    this->SendAlert(AlertLevel::Fatal, AlertDescription::HandshakeFailure)
                    this->State := ServerState::Closed
                }

                Free(ExpectedVerifyData)
            }
        }

        define void OnChangeCipherSpec(NetworkPacket* Packet) {
            if (this->State != ServerState::ClientKeyExchanged) {
                Print("Unexpected ChangeCipherSpec\n")
                Exit(1)
            }

            this->RecordLayer->EnableRemoteEncryption()

            this->State := ServerState::ClientChangedCipher
        }

        define void SendApplicationData(void* Data, i32 Size) {
            NetworkPacket* Packet := this->RecordLayer->Enter(TLS::RecordProtocol::ContentType::ApplicationData)
            MoveMemory(Packet->Bump(Size), Data, Size)
            this->RecordLayer->Leave(Packet)
        }

        define void OnApplicationData(NetworkPacket* Packet) {
            TLS::RecordProtocol::RecordHeader* Header := Packet->Get("TLS::RecordProtocol::Record")
            void* Body := (Header As void*) + #TLS::RecordProtocol::RecordHeader
            i32 Size := Header->Length

            *((Body + Size - 16) As i8*) := 0

            Print("Got Application Data: %s", Body + 8)

            if (CompareMemory(Body + 8, "GET / HTTP/1.1", 14)) {
                Print("Received HTTP Request:\n%s\n", Body + 8)

                this->SendApplicationData(
                    "HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello, world!",
                    52
                )
            }
        }
        

        define void Establish() {
            while (this->State != ServerState::Established) {
                this->RecordLayer->TryReceive()

                if (this->State = ServerState::Closed) {
                    Print("Connection closed!\n")
                }
            }
        }

        define void New(Socket Remote, TLS::Security::ICertificate* Certificate) {
            this->Remote := Remote
            this->SigningCertificate := Certificate

            this->RecordLayer := new TLS::RecordProtocol::Layer(Remote)
            this->HandshakeLayer := new TLS::HandshakeProtocol::Layer(this->RecordLayer)

            this->RecordLayer->SetVersion(TLS::VersionNumber::TLS_1_0)

            this->RegisterContentType(TLS::RecordProtocol::ContentType::Handshake, this->HandshakeLayer)

            INetworkLayer* OnChangeCipherSpec := this->MakeCallback(&self.OnChangeCipherSpec)
            this->RegisterContentType(TLS::RecordProtocol::ContentType::ChangeCipherSpec, OnChangeCipherSpec)

            INetworkLayer* OnApplicationData := this->MakeCallback(&self.OnApplicationData)
            this->RegisterContentType(TLS::RecordProtocol::ContentType::ApplicationData, OnApplicationData)

            INetworkLayer* OnAlert := this->MakeCallback(&self.OnAlert)
            this->RegisterContentType(TLS::RecordProtocol::ContentType::Alert, OnAlert)

            this->ClientHello := new TLS::HandshakeProtocol::ClientHelloHelper(TLS::VersionNumber::TLS_1_2)
            this->ServerHello := new TLS::HandshakeProtocol::ServerHelloHelper()
            this->Certificates := new TLS::HandshakeProtocol::CertificateHelper()
            ;this->ServerKeyExchange := new TLS::HandshakeProtocol::ServerKeyExchangeHelper()

            this->ServerHello->SetVersion(TLS::VersionNumber::TLS_1_2)

            this->Certificates->Add(this->SigningCertificate)

            INetworkLayer* OnHandshake := this->MakeCallback(&self.OnHandshake)

            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ClientHello, OnHandshake)
            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ClientKeyExchange, OnHandshake)
            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::Finished, OnHandshake)

            this->State := ServerState::AwaitingClientHello
        }
    }


    class Client derives INew {
        ClientState State

        Socket Remote

        TLS::RecordProtocol::Layer* RecordLayer
        TLS::HandshakeProtocol::Layer* HandshakeLayer

        define void RegisterContentType(TLS::RecordProtocol::ContentType Type, INetworkLayer* Layer) {
            this->RecordLayer->RegisterContentType(Type, Layer)
        }
        define void RegisterMessageType(TLS::HandshakeProtocol::MessageType Type, INetworkLayer* Layer) {
            this->HandshakeLayer->RegisterMessageType(Type, Layer)
        }

        TLS::Security::SecurityParameters* Security
        TLS::Security::ICipherSuite* CipherSuite

        TLS::HandshakeProtocol::ClientHelloHelper* ClientHello
        TLS::HandshakeProtocol::ServerHelloHelper* ServerHello
        ;TLS::HandshakeProtocol::ServerKeyExchangeHelper* ServerKeyExchange

        HandshakeProtocol::CertificateHelper* Certificate

        CallbackNetworkLayer* OnHandshakeCallback

        define CallbackNetworkLayer* MakeCallback(void(void*, NetworkPacket*) Method) {
            return new CallbackNetworkLayer(this, Method)
        }

        define void OnChangeCipherSpec(NetworkPacket* Packet) {
            if (this->State != ClientState::ServerHelloDone) {
                Print("Unexpected ChangeCipherSpec\n")
                Exit(1)
            }

            this->RecordLayer->EnableRemoteEncryption()

            this->State := ClientState::ServerChangedCipher
        }

        define void SendAlert(AlertLevel Level, AlertDescription Description) {
            NetworkPacket* Packet := this->RecordLayer->Enter(TLS::RecordProtocol::ContentType::Alert)

            AlertRecord* Alert := Packet->Mark("TLS::AlertProtocol::Alert", #AlertRecord)

            Alert->Level := Level
            Alert->Description := Description

            this->RecordLayer->Leave(Packet)
        }

        define void Close() {
            this->SendAlert(AlertLevel::Warning, AlertDescription::CloseNotify)

            this->State := ClientState::ClientClosed
        }

        define void OnAlert(NetworkPacket* Packet) {
            AlertRecord* Alert := Packet->Mark("TLS::AlertProtocol::Alert", #AlertRecord)

            Print("Received alert at %s level, description %s\n", nameof:(Alert->Level), nameof:(Alert->Description))

            if (Alert->Description = AlertDescription::CloseNotify) {
                if (this->State = ClientState::Established) {
                    this->SendAlert(AlertLevel::Warning, AlertDescription::CloseNotify)
                    this->State := ClientState::Closed
                }
                else if (this->State = ClientState::ClientClosed) {
                    this->State := ClientState::Closed
                }
            }
            else if (Alert->Level = AlertLevel::Fatal) {
                this->SendAlert(AlertLevel::Warning, AlertDescription::CloseNotify)
                this->State := ClientState::Closed
            }
        }

        define void SendClientHello() {
            this->State := ClientState::ConnectionOffered

            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::ClientHello)

            this->ClientHello->Write(Packet)

            this->HandshakeLayer->Leave(Packet)
        }

        define void SendClientKeyExchange() {
            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::ClientKeyExchange)
            MoveMemory(Packet->Bump(1), i8[32], 1)
            MoveMemory(Packet->Bump(32), this->Security~>Client->PublicKey, 32)

            this->HandshakeLayer->Leave(Packet)
        }

        define void SendChangeCipherSpec() {
            NetworkPacket* Packet := this->RecordLayer->Enter(TLS::RecordProtocol::ContentType::ChangeCipherSpec)

            MoveMemory(Packet->Bump(1), i8[1], 1)

            this->RecordLayer->Leave(Packet)
        }

        define void* CalculateVerifyData(i8* Label, i32 IgnoreHandshakeCount) {
            IHashFunction* Hash := this->CipherSuite->GetHashFunction()

            Hash->Prepare()

            i32 HandshakeCount := this->HandshakeLayer->Messages->Count() - IgnoreHandshakeCount

            for (i32 Index := 0, Index < HandshakeCount, Index++) {
                NetworkPacket* Message := this->HandshakeLayer->Messages->At(Index)

                ;Print("Handshake Message %i:\n%hexdump\n", Index, Message->Buffer, Message->Size)

                Hash->Update(Message->Buffer, Message->Size)
            }

            HashFunctionInfo Info
            Hash->GetInfo(&Info)

            void* HandshakeHash := Alloc(Info.OutputSize)

            Hash->Finalize(HandshakeHash)

            TLS::Security::IPseudoRandomFunction* PRF := this->CipherSuite->GetPseudoRandomFunction()

            void* VerifyData := PRF->Generate(this->Security->MasterSecret, 48, Label, HandshakeHash, Info.OutputSize, 12)

            Free(HandshakeHash)

            return VerifyData
        }

        define void SendClientHelloDone() {
            NetworkPacket* Packet := this->HandshakeLayer->Enter(TLS::HandshakeProtocol::MessageType::Finished)

            void* VerifyData := this->CalculateVerifyData("client finished", 0)
            MoveMemory(Packet->Bump(12), VerifyData, 12)
            Free(VerifyData)

            this->HandshakeLayer->Leave(Packet)
        }

        define void SendApplicationData(void* Data, i32 Size) {
            NetworkPacket* Packet := this->RecordLayer->Enter(TLS::RecordProtocol::ContentType::ApplicationData)

            MoveMemory(Packet->Bump(Size), Data, Size)

            this->RecordLayer->Leave(Packet)
        }

        define void ExpectState(ClientState Expected, i8* What) {
            if (this->State != Expected) {
                Print("Unexpected %s while in state %s. %s expected in %s state\n", What, nameof:(this->State), What, nameof:(Expected))
                Exit(1)
            }
        }

        define void OnHandshake(NetworkPacket* Packet) {
            TLS::HandshakeProtocol::HandshakeRecord* Record := Packet->Get("TLS::HandshakeProtocol::Record")

            if (Record->Type = TLS::HandshakeProtocol::MessageType::ServerHello) {
                this->ExpectState(ClientState::ConnectionOffered, "ServerHello")

                this->RecordLayer->SetVersion(TLS::VersionNumber::TLS_1_2)

                this->ServerHello->Read(Packet)

                auto Parameters := new TLS::Security::SecurityParameters()

                Parameters->SetLocalIsClient()

                Parameters->ServerHello := this->ServerHello

                this->Security := Parameters

                if (this->ServerHello->Cipher = TLS::CipherSuite::ECDH_RSA_WITH_AES_128_SHA256) {
                    ; pass
                }
                else if (this->ServerHello->Cipher = TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256) {
                    ; pass
                }
                else {
                    Print("Unsupported CipherSuite %s (%x)\n", nameof:(this->ServerHello->Cipher), this->ServerHello->Cipher)
                    Exit(1)
                }

                Parameters~>Client->Random := this->ClientHello->Random
                Parameters~>Server->Random := this->ServerHello->Random

                ;Print("Server Random:\n%hexdump\n", this->ServerHello->Random, 32)

                Print("Server selected CipherSuite %s\n", nameof:(this->ServerHello->Cipher))

                i32 Count := this->ServerHello->Extensions->Count()
                Print("Server replied with %i extensions\n", Count)

                for (i32 Index := 0, Index < Count, Index++) {
                    TLS::HandshakeProtocol::ExtensionEntry* Entry := this->ServerHello->Extensions->At(Index)

                    Print("[%i]: %s (%x bytes)\n", Index, nameof:(Entry->Type), Entry->Length)
                }

                this->State := ClientState::ServerAccepted
            }
            else if (Record->Type = TLS::HandshakeProtocol::MessageType::Certificate) {
                this->ExpectState(ClientState::ServerAccepted, "Certificate")

                this->Certificate->Read(Packet)

                this->State := ClientState::ServerSentCertificate
            }
            else if (Record->Type = TLS::HandshakeProtocol::MessageType::ServerKeyExchange) {
                this->ExpectState(ClientState::ServerSentCertificate, "ServerKeyExchange")

                ;this->ServerKeyExchange->Read(Packet)

                ;Print("Server Curve Type: %s\n", nameof:(this->ServerKeyExchange->Type))
                ;Print("Server Curve: %s\n", nameof:(this->ServerKeyExchange->Curve))

                ;Print("Server Public Key:\n%hexdump\n", this->ServerKeyExchange->PublicKey, this->ServerKeyExchange->PublicKeyLength)

                ;Print("Server Signature Algorithm: %s\n", nameof:(this->ServerKeyExchange->Algorithm))

                ;Print("Server Signature:\n%hexdump\n", this->ServerKeyExchange->Signature, this->ServerKeyExchange->SignatureLength)

                ;this->Security->ServerKeyExchange := this->ServerKeyExchange
                ;this->Security~>Server->PublicKey := this->ServerKeyExchange->PublicKey

                ;this->Security->LocalPrivateKey := "thirty two bytes of random!"

                if (this->ServerHello->Cipher = TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256) {
                    this->CipherSuite := new TLS::Security::ECDHE_RSA_WITH_AES_128_GCM_SHA256::Suite(this->Security)
                }
                ;else if (this->ServerHello->Cipher = TLS::CipherSuite::ECDH_RSA_WITH_AES_128_SHA256) {
                ;    this->CipherSuite := new TLS::EncryptedRecordProtocol::ECDH_RSA_WITH_AES_128_SHA256(this->SecurityParameters)
                ;}
                else {
                    Print("Unsupported CipherSuite %s (%x)\n", nameof:(this->ServerHello->Cipher), this->ServerHello->Cipher)
                    Exit(1)
                }

                this->State := ClientState::ServerKeyExchanged
            }
            else if (Record->Type = TLS::HandshakeProtocol::MessageType::ServerHelloDone) {
                this->ExpectState(ClientState::ServerKeyExchanged, "ServerHelloDone")

                this->RecordLayer->JoinNext(3)

                this->SendClientKeyExchange()
                this->SendChangeCipherSpec()

                this->RecordLayer->SetSecurityParameters(this->Security, this->CipherSuite)
                this->RecordLayer->EnableLocalEncryption()

                this->SendClientHelloDone()

                this->State := ClientState::ServerHelloDone
            }
            else if (Record->Type = TLS::HandshakeProtocol::MessageType::Finished) {
                this->ExpectState(ClientState::ServerChangedCipher, "Finished")

                Print("Received Finished\n")

                void* CalculatedVerifyData := this->CalculateVerifyData("server finished", 1)
                void* ProvidedVerifyData := Packet->Get("TLS::HandshakeProtocol::Data")

                Print("Expected Verify Data:\n%hexdump\n", CalculatedVerifyData, 12)
                Print("Received Verify Data:\n%hexdump\n", ProvidedVerifyData, 12)

                if (CompareMemory(CalculatedVerifyData, ProvidedVerifyData, 12)) {
                    Print("Server Finished verify data matches!\n")
                }
                else {
                    Print("Server Finished verify data does not match!\n")
                    Exit(1)
                }

                Free(CalculatedVerifyData)

                ;this->SendApplicationData("GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n", 55)

                this->State := ClientState::Established
            }
            else {
                Print("Unhandled handshake message %s (%x)\n", nameof:(Record->Type), Record->Type)
            }
        }

        define void OnApplicationData(NetworkPacket* Packet) {
            TLS::RecordProtocol::RecordHeader* Header := Packet->Get("TLS::RecordProtocol::Record")
            void* Body := (Header As void*) + #TLS::RecordProtocol::RecordHeader
            i32 Size := Header->Length

            *((Body + Size - 16) As i8*) := 0

            Print("Got Application Data: %s", Body + 8)
        }

        define void Establish(i8* ServerName) {
            i8[32] ClientRandom
            SecureFillRandom(ClientRandom, 32)

            this->ClientHello->SetRandom(ClientRandom)
            this->ClientHello->AddCipherSuite(TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256)
            this->ClientHello->AddCompressionMethod(TLS::HandshakeProtocol::CompressionMethod::Null)

            ;this->ClientHello->AddServerHostName(ServerName)

            ;this->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::Ed25519)
            ;this->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::Ed448)
            ;this->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::RSA_PKCS1_SHA256) ; this is a lie
            ;this->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::RSA_PKCS1_SHA512) ; this is a lie

            ;this->ClientHello->AddSupportedGroup(TLS::HandshakeProtocol::NamedCurve::x25519)
            ;this->ClientHello->AddSupportedGroup(TLS::HandshakeProtocol::NamedCurve::x448)

            ;this->ClientHello->AddPointFormat(TLS::HandshakeProtocol::ECPointFormat::Uncompressed)

            this->SendClientHello()

            while (this->State != ClientState::Established) {
                this->RecordLayer->TryReceive()

                if (this->State = ClientState::Closed) {
                    Print("Connection closed due to error\n")
                    Exit(1)
                }
            }
        }

        define void Receive() {
            this->RecordLayer->TryReceive()
        }

        define void New(Socket Remote) {
            this->Remote := Remote
            this->RecordLayer := new TLS::RecordProtocol::Layer(Remote)
            this->HandshakeLayer := new TLS::HandshakeProtocol::Layer(this->RecordLayer)

            this->RecordLayer->SetVersion(TLS::VersionNumber::TLS_1_0)

            this->RegisterContentType(TLS::RecordProtocol::ContentType::Handshake, this->HandshakeLayer)

            this->ClientHello := new TLS::HandshakeProtocol::ClientHelloHelper(TLS::VersionNumber::TLS_1_2)
            this->ServerHello := new TLS::HandshakeProtocol::ServerHelloHelper()
            ;this->ServerKeyExchange := new TLS::HandshakeProtocol::ServerKeyExchangeHelper()
            this->Certificate := new HandshakeProtocol::CertificateHelper()

            INetworkLayer* OnChangeCipherSpec := this->MakeCallback(&self.OnChangeCipherSpec)

            this->RegisterContentType(TLS::RecordProtocol::ContentType::ChangeCipherSpec, OnChangeCipherSpec)

            INetworkLayer* OnHandshake := this->MakeCallback(&self.OnHandshake)

            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerHello, OnHandshake)
            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerKeyExchange, OnHandshake)
            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::Certificate, OnHandshake)
            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::ServerHelloDone, OnHandshake)
            this->RegisterMessageType(TLS::HandshakeProtocol::MessageType::Finished, OnHandshake)

            INetworkLayer* OnApplicationData := this->MakeCallback(&self.OnApplicationData)

            this->RegisterContentType(TLS::RecordProtocol::ContentType::ApplicationData, OnApplicationData)
        }
    }
}

#Require "./src/DNS.rlx"

define void Client(i8* Server, i32 Port) {
    UseDNS(ParseIPV4("1.1.1.1"), 53, 1 * 60, 10 * 60, false)

    IPV4SocketAddress* ServerAddress := DNSLookupIPV4(Server, Port As i16)

    if (ServerAddress = null) {
        Print("Could not resolve %s\n", Server)
        Exit(1)
    }

    Print("Resolved %s to %ipv4\n", Server, ServerAddress)

    Socket S := Socket:New(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    S->Connect(ServerAddress~>Base, #IPV4SocketAddress)


    ;SocketNetworkLayer* Base := new SocketNetworkLayer(new IPV4SocketAddress("24.124.77.9", 443))
    ;SocketNetworkLayer* Base := new SocketNetworkLayer(new IPV4SocketAddress("142.250.125.101", 443))

    ;Socket S := Socket:New(AF_INET, SOCK_STREAM, IPPROTO_TCP)
    ;S->Connect(new IPV4SocketAddress("142.250.125.101", 443)~>Base, #IPV4SocketAddress)
    ;S->Connect(new IPV4SocketAddress("127.0.0.1", 4433)~>Base, #IPV4SocketAddress)

    TLS::Client* C := new TLS::Client(S)

    C->Establish(Server)

    i8* GetRequest := FormatString("GET / HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n", Server)

    C->SendApplicationData(GetRequest, StringLength(GetRequest))

    C->RecordLayer->TryReceive()

    C->Close()

    /* i8[32] RandomBytes
    SecureFillRandom(RandomBytes, 32)

    C->ClientHello->SetRandom(RandomBytes)
    C->ClientHello->AddCipherSuite(TLS::CipherSuite::ECDHE_RSA_WITH_AES_128_GCM_SHA256)
    ;C->ClientHello->AddCipherSuite(TLS::CipherSuite::RSA_WITH_AES_128_GCM_SHA256)
   ;C->ClientHello->AddCipherSuite(TLS::CipherSuite::ECDH_RSA_WITH_AES_128_SHA256)
    C->ClientHello->AddCompressionMethod(TLS::HandshakeProtocol::CompressionMethod::Null)

    C->ClientHello->AddServerHostName("google.com")

    ;C->ClientHello->AddExtension(TLS::HandshakeProtocol::ExtensionType::ExtendedMasterSecret)
    ;C->ClientHello->AddExtension(TLS::HandshakeProtocol::ExtensionType::EncryptThenMAC)

    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::Ed25519)
    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::Ed448)
    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::RSA_PKCS1_SHA256)
    C->ClientHello->AddSignatureAlgorithm(TLS::HandshakeProtocol::SignatureAlgorithm::RSA_PKCS1_SHA512)

    C->ClientHello->AddSupportedGroup(TLS::HandshakeProtocol::NamedCurve::x25519)
    C->ClientHello->AddSupportedGroup(TLS::HandshakeProtocol::NamedCurve::x448)

    C->ClientHello->AddPointFormat(TLS::HandshakeProtocol::ECPointFormat::Uncompressed)
 */
    

    ;C->Establish()

    ;C->Poll(-1)

    /*
    Plumbing* P := new Plumbing()

    NetworkPacket* Packet := new NetworkPacket(SERVER_HELLO_TEST_SIZE + 1)
    MoveMemory(Packet->Buffer, SERVER_HELLO_TEST, SERVER_HELLO_TEST_SIZE)

    P->RecordLayer->Process(Packet)

    Packet->DumpMarkers()*/
}

#Require "./src/Time.rlx"

define void* ReadFile(i8* Path, i32* OutSize) {
    i64 F := FileOpen(Path, FILE_READ)

    if (F < 0) {
        Print("Failed to open file %s\n", Path)
        Exit(1)
    }

    i64 Size := FileGetSize(F)

    void* Buffer := Alloc(Size)
    FileRead(F, Buffer, Size As i32)

    FileClose(F)

    if (OutSize != null) {
        *OutSize := Size As i32
    }

    return Buffer
}

#Require "./src/PEM.rlx"

define TLS::Security::ICertificate* LoadCertificate(i8* PrivateKeyPath, i8* CertificatePath) {
    i32 PrivateKeyPEMSize := 0
    i8* PrivateKeyPEM := ReadFile(PrivateKeyPath, &PrivateKeyPEMSize)

    i32 CertificatePEMSize := 0
    i8* CertificatePEM := ReadFile(CertificatePath, &CertificatePEMSize)

    i32 CertificateDataSize := 0
    void* CertificateData := ParsePEM(
        "-----BEGIN CERTIFICATE-----\r",
        "\r-----END CERTIFICATE-----\r",
        &CertificateDataSize,
        CertificatePEM,
        CertificatePEMSize
    )

    ASN1::PKCS8::Parser* PrivateKeyParser := new ASN1::PKCS8::Parser()
    ASN1::PKCS8::PrivateKeyInfo* PrivateKeyInfo := PrivateKeyParser->ParsePEM(PrivateKeyPEM, PrivateKeyPEMSize)

    if (PrivateKeyInfo->Algorithm != ASN1::X509::AlgorithmIdentifier::RSA_ENCRYPTION) {
        Print("Unsupported private key algorithm %s\n", nameof:(PrivateKeyInfo->Algorithm))
        Exit(1)
    }

    ASN1::PKCS8::RSAPrivateKey* PrivateKey := PrivateKeyInfo->PrivateKey

    TLS::Security::RSACertificate* Result := new TLS::Security::RSACertificate(PrivateKey, null, CertificateData, CertificateDataSize)

    return Result
}

#Require "./src/network/epoll.rlx"

define void Main(i32 ArgC, i8** ArgV) {
    if (ArgC < 2) {
        Print("Usage: %s <client|server> <args>\n", ArgV[0])
        Exit(1)
    }

    if (StringEquals(ArgV[1], "client")) {
        i32 Port := 443
        i8* Server := "google.com"

        if (ArgC >= 3) {
            Server := ArgV[2]
        }
        
        if (ArgC >= 4) {
            Port := AToI(ArgV[3]) As i32
        }

        if (Port < 1 || Port > 65535) {
            Print("Invalid port %s\n", ArgV[3])
            Exit(1)
        }

        Client(Server, Port)
    }
    else if (StringEquals(ArgV[1], "server")) {
        i8* PrivateKeyPath := "key.pem"
        i8* CertificatePath := "cert.pem"

        TLS::Security::ICertificate* Certificate := LoadCertificate(PrivateKeyPath, CertificatePath)

        TLS::Security::RSACertificate* RSACert := (Certificate As TLS::Security::RSACertificate*)

        ASN1::PKCS8::RSAPrivateKey* PrivateKey := RSACert->PrivateKey

        PrivateKey->Print()

        i32 Port := 4433

        if (ArgC >= 3) {
            Port := AToI(ArgV[2]) As i32
        }

        IPV4SocketAddress* Address := new IPV4SocketAddress("0.0.0.0", Port As i16)
        Socket S := Socket:New(AF_INET, SOCK_STREAM, IPPROTO_TCP)
        S->SetOption(SO_REUSEADDR, 1)
        
        while (S->Bind(Address~>Base, #IPV4SocketAddress) != 0) {
            Print("Failed to bind to %ipv4, retrying in 5 seconds...\n", Address)
            MilliSleep(5000)
        }

        S->Listen(5)
        Print("Listening on %ipv4\n", Address)

        i64 epoll_fd := epoll_create()
        epoll_ctl(epoll_fd, EPOLL_CONTROL_ADD, S As i64, EPOLL_EVENT_IN)

        epoll_event* events := Alloc(4 * #epoll_event)

        PointerArray* Clients := new PointerArray() ; TLS::Server

        loop {
            if (S->Poll(POLL_FOR_READ, 0)) {
                Print("New connection!\n")

                IPV4SocketAddress* ClientAddress := new IPV4SocketAddress()
                Socket ClientSocket := S->Accept(ClientAddress~>Base, #IPV4SocketAddress)

                Print("Accepted connection from %ipv4\n", ClientAddress)

                Clients->Push(new TLS::Server(ClientSocket, Certificate))

                events := ReAlloc(events, (#epoll_event) * (Clients->Count() + 1))
                epoll_ctl(epoll_fd, EPOLL_CONTROL_ADD, ClientSocket As i64, EPOLL_EVENT_IN)
            }


            i32 Count := Clients->Count()

            for (i32 Index := 0, Index < Count, Index++) {
                TLS::Server* Client := Clients->At(Index)

                Client->RecordLayer->TryReceive()
            }

            i64 Result := epoll_wait(epoll_fd, events, Clients->Count() + 1, 1000)

            ;Print("epoll_wait returned %i\n", Result)


        }
    }
    else {
        Print("Unknown mode %s\n", ArgV[1])
        Exit(1)
    }
    
}