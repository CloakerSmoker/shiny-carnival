
#Require "$/AVLTree.rlx"
#Require "$/PointerArray.rlx"

#Require "./src/Endianess.rlx"
#Require "./src/network/Packet.rlx"

#Require "./src/HMAC.rlx"

#Require "./src/TLS/Core.rlx"

namespace TLS::RecordProtocol {
    enum ConnectionEnd {
        Server,
        Client
    }

    enum CompressionAlgorithmName {
        Null
    }

    struct ProtocolVersion {
        i8 Major
        i8 Minor
    }

    enum ContentType As i8 {
        ChangeCipherSpec := 20
        Alert := 21
        Handshake := 22
        ApplicationData := 23
    }

    struct RecordHeader unaligned {
        ContentType Type
        ProtocolVersion Version
        i16 Length
    }

    struct CipherTextRecord {
        ContentType Type
        ProtocolVersion Version
        i16 Length
    }

    struct AuthenticatedData unaligned {
        i64 SequenceNumber
        RecordProtocol::ContentType Type
        RecordProtocol::ProtocolVersion Version
        i16 Length
    }

    class Layer derives INew {
        INetworkLayer* Base
        Security::SecurityParameters* Parameters
        Security::ICipherSuite* Suite

        i64 SendSequenceNumber
        i64 ReceiveSequenceNumber

        RecordProtocol::ProtocolVersion Version

        define void SetVersion(VersionNumber Version) {
            this~>Version->Major := Version.Major()
            this~>Version->Minor := Version.Minor()
        }

        i32 JoinNextPackets
        NetworkPacket* Current

        define void JoinNext(i32 Count) {
            this->JoinNextPackets := Count
            this->Current := this->Base->Enter()
        }

        define void EnableEncryption(Security::SecurityParameters* Parameters, Security::ICipherSuite* Suite) {
            this->Parameters := Parameters
            this->Suite := Suite
        }

        define NetworkPacket* Enter(ContentType Type, i8 EnableEncryption) {
            NetworkPacket* Packet := this->Current

            if (this->JoinNextPackets) {
                Packet->ClearMarkers()

                this->JoinNextPackets -= 1
            }
            else {
                Packet := this->Base->Enter()
            }

            RecordProtocol::RecordHeader* Header := Packet->Mark("TLS::RecordProtocol::Record", #RecordProtocol::RecordHeader)
            
            MoveMemory(Header~>Version, this~>Version, #RecordProtocol::ProtocolVersion)
            Header->Type := Type

            Print("Entering Record Layer for %s, Encryption: %i\n", nameof:(Type), EnableEncryption)

            if (EnableEncryption) {
                if (this->Suite = null) {
                    Print("No cipher suite selected for encrypted layer\n")
                    Exit(1)
                }

                Packet->Mark("TLS::EncryptedRecordProtocol::Body", this->Suite->CalculateLeadingCipherTextSize())
            }

            return Packet
        }

        define void Leave(NetworkPacket* Packet) {
            if (Packet->Find("TLS::EncryptedRecordProtocol::Body")) {
                ; Packet wants encryption

                i32 LeadingSize := this->Suite->CalculateLeadingCipherTextSize()

                void* Data := Packet->Get("TLS::EncryptedRecordProtocol::Body")
                i32 Size := Packet->Tell() - Packet->GetOffset("TLS::EncryptedRecordProtocol::Body") - LeadingSize

                Print("Leaving Encrypted Layer with %i bytes of body data\n", Size)

                i32 FollowingSize := this->Suite->CalculateFollowingCipherTextSize(Data, Size)

                if (FollowingSize) {
                    Packet->Bump(FollowingSize)
                }

                Packet->Find("TLS::EncryptedRecordProtocol::Body")->Size := LeadingSize + Size + FollowingSize

                Print("    %i bytes of total ciphertext\n", Packet->GetSize("TLS::EncryptedRecordProtocol::Body"))
            }            
            
            RecordProtocol::RecordHeader* Header := Packet->Get("TLS::RecordProtocol::Record")
            i32 HeaderEndOffset := Packet->GetEndOffset("TLS::RecordProtocol::Record")

            Print("Send record of length: %i\n", Packet->Offset - HeaderEndOffset)

            Header->Length := Swap16((Packet->Offset - HeaderEndOffset) As i16)

            Packet->End()

            if (Packet->Find("TLS::EncryptedRecordProtocol::Body")) {
                AuthenticatedData Authenticate {
                    SequenceNumber: Swap64(this->SendSequenceNumber),
                    Type: Header->Type,
                    Version: {
                        Major: this->Version->Major,
                        Minor: this->Version->Minor
                    },
                    Length: Swap16(Size As i16)
                }

                Print("AAD:\n%hexdump\n", &Authenticate, #AuthenticatedData)

                this->Suite->Encrypt(
                    Data, Size,
                    &Authenticate, #AuthenticatedData
                )
            }

            Print("Joining next %i packets\n", this->JoinNextPackets)

            if !(this->JoinNextPackets) {
                this->Base->Leave(Packet)
            }
        }

        AVLTree* ContentTypeHandlers ; <INetworkLayer*>

        define void RegisterContentType(ContentType Type, INetworkLayer* Handler) {
            this->ContentTypeHandlers->InsertPointer(Type As i32, Handler)
        }

        define void Process(NetworkPacket* Packet) {
            while (Packet->Offset < Packet->Size) {
                Packet->ClearMarkers()
                RecordHeader* Header := Packet->Mark("TLS::RecordProtocol::Record", #RecordHeader)
                
                Header->Length := Swap16(Header->Length)
                Packet->Extend("TLS::RecordProtocol::Record", Header->Length)


                ContentType Type := Header->Type
                INetworkLayer* Handler := this->ContentTypeHandlers->GetPointer(Type As i32)

                if (Handler) {
                    Handler->Process(Packet)
                }
                else {
                    Print("No handler for content type %i (%s)\n", Type, nameof:(Type))
                }

                Packet->Seek(Packet->GetEndOffset("TLS::RecordProtocol::Record"))

                Print("%x/%x\n", Packet->Offset, Packet->Size)

                ;break
            }
        }

        define void New(INetworkLayer* Base) {
            this->Base := Base

            this->ContentTypeHandlers := new AVLTree(#void*)
        }
    }
}

define void DoPrintDump(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
    i8* Buffer := Parameters[*ParameterIndex] As void*
    i32 Size := Parameters[*ParameterIndex + 1] As i32

    for (i32 Index := 0, Index < Size, Index++) {
        this->Print("%B", Buffer[Index])

        if (Index + 1 != Size) {
            this->Print(" ")
        }
    }

    *ParameterIndex += 2
}

PrintFormatPrototype DumpPrintPrototype {
    Name: "dump",
    Format: &DoPrintDump
}

i32 DUMP_PRINT_PROTOTYPE_ID := AddPrintFormat(&DumpPrintPrototype)