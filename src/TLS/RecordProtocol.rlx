
#Require "$/AVLTree.rlx"
#Require "$/PointerArray.rlx"

#Require "./src/Endianess.rlx"
#Require "./src/network/Packet.rlx"

#Require "./src/HMAC.rlx"

#Require "./src/TLS/Core.rlx"

namespace TLS::RecordProtocol {
    enum ConnectionEnd {
        Server,
        Client
    }

    enum CompressionAlgorithmName {
        Null
    }

    struct ProtocolVersion {
        i8 Major
        i8 Minor
    }

    enum ContentType As i8 {
        ChangeCipherSpec := 20
        Alert := 21
        Handshake := 22
        ApplicationData := 23
    }

    struct RecordHeader unaligned {
        ContentType Type
        ProtocolVersion Version
        i16 Length
    }

    struct CipherTextRecord {
        ContentType Type
        ProtocolVersion Version
        i16 Length
    }

    struct AuthenticatedData unaligned {
        i64 SequenceNumber
        RecordProtocol::ContentType Type
        RecordProtocol::ProtocolVersion Version
        i16 Length
    }

    class Layer derives INew {
        INetworkLayer* Base
        Security::SecurityParameters* Parameters
        Security::ICipherSuite* Suite

        i8 LocalEncryption
        i8 RemoteEncryption

        i64 SendSequenceNumber
        i64 ReceiveSequenceNumber

        RecordProtocol::ProtocolVersion Version

        define void SetVersion(VersionNumber Version) {
            this~>Version->Major := Version.Major()
            this~>Version->Minor := Version.Minor()
        }

        i32 JoinNextPackets
        NetworkPacket* Current

        define void JoinNext(i32 Count) {
            this->JoinNextPackets := Count
            this->Current := this->Base->Enter()
        }

        define void EnableLocalEncryption(Security::SecurityParameters* Parameters, Security::ICipherSuite* Suite) {
            this->Parameters := Parameters
            this->Suite := Suite

            this->LocalEncryption := true
        }

        define void EnableRemoteEncryption() {
            this->RemoteEncryption := true
        }

        define NetworkPacket* Enter(ContentType Type) {
            NetworkPacket* Packet := this->Current

            if (this->JoinNextPackets) {
                Packet->ClearMarkers()

                this->JoinNextPackets -= 1
            }
            else {
                Packet := this->Base->Enter()
            }

            RecordProtocol::RecordHeader* Header := Packet->Mark("TLS::RecordProtocol::Record", #RecordProtocol::RecordHeader)
            
            MoveMemory(Header~>Version, this~>Version, #RecordProtocol::ProtocolVersion)
            Header->Type := Type

            Print("Entering Record Layer for %s, Encryption: %i\n", nameof:(Type), this->LocalEncryption)

            if (this->LocalEncryption) {
                Packet->Mark("TLS::EncryptedRecordProtocol::Body", this->Suite->CalculateLeadingCipherTextSize())
            }

            return Packet
        }

        define void Leave(NetworkPacket* Packet) {
            if (this->LocalEncryption) {
                i32 LeadingSize := this->Suite->CalculateLeadingCipherTextSize()

                void* Data := Packet->Get("TLS::EncryptedRecordProtocol::Body")
                i32 Size := Packet->Tell() - Packet->GetOffset("TLS::EncryptedRecordProtocol::Body") - LeadingSize

                Print("Leaving Encrypted Layer with %i bytes of body data\n", Size)

                i32 FollowingSize := this->Suite->CalculateFollowingCipherTextSize(Data, Size)

                if (FollowingSize) {
                    Packet->Bump(FollowingSize)
                }

                Packet->Find("TLS::EncryptedRecordProtocol::Body")->Size := LeadingSize + Size + FollowingSize

                Print("    %i bytes of total ciphertext\n", Packet->GetSize("TLS::EncryptedRecordProtocol::Body"))
            }            
            
            RecordProtocol::RecordHeader* Header := Packet->Get("TLS::RecordProtocol::Record")
            i32 HeaderEndOffset := Packet->GetEndOffset("TLS::RecordProtocol::Record")

            Print("Send record of length: %i\n", Packet->Offset - HeaderEndOffset)

            Header->Length := Swap16((Packet->Offset - HeaderEndOffset) As i16)

            Packet->End()

            if (this->LocalEncryption) {
                AuthenticatedData Authenticate {
                    SequenceNumber: Swap64(this->SendSequenceNumber),
                    Type: Header->Type,
                    Version: {
                        Major: this->Version->Major,
                        Minor: this->Version->Minor
                    },
                    Length: Swap16(Size As i16)
                }

                Print("AAD:\n%hexdump\n", &Authenticate, #AuthenticatedData)

                this->Suite->Encrypt(
                    Data, Size,
                    &Authenticate, #AuthenticatedData
                )

                this->SendSequenceNumber += 1
            }

            Print("Joining next %i packets\n", this->JoinNextPackets)

            if !(this->JoinNextPackets) {
                this->Base->Leave(Packet)
            }
        }

        AVLTree* ContentTypeHandlers ; <INetworkLayer*>

        define void RegisterContentType(ContentType Type, INetworkLayer* Handler) {
            this->ContentTypeHandlers->InsertPointer((Type As i32) & 0xFF, Handler)
        }

        define void Process(NetworkPacket* Packet) {
            while (Packet->Offset < Packet->Size) {
                Packet->ClearMarkers()
                RecordHeader* Header := Packet->Mark("TLS::RecordProtocol::Record", #RecordHeader)
                
                Header->Length := Swap16(Header->Length)
                Packet->Extend("TLS::RecordProtocol::Record", Header->Length)

                ;Print("Record %i bytes:\n%hexdump\n", Header->Length + #RecordHeader, Header, Header->Length + #RecordHeader)

                ContentType Type := Header->Type

                if (this->RemoteEncryption) {
                    if (Type != ContentType::ChangeCipherSpec) {
                        void* Body := Packet->Get("TLS::RecordProtocol::Record") + #RecordHeader

                        i32 Prepend := this->Suite->CalculateLeadingCipherTextSize()
                        i32 Append := this->Suite->CalculateFollowingCipherTextSize(Body, Header->Length)

                        AuthenticatedData Authenticate {
                            SequenceNumber: Swap64(this->ReceiveSequenceNumber),
                            Type: Header->Type,
                            Version: {
                                Major: Header~>Version->Major,
                                Minor: Header~>Version->Minor
                            },
                            Length: Swap16((Header->Length - Prepend - Append) As i16)
                        }

                        this->Suite->Decrypt(
                            Body, Header->Length,
                            &Authenticate, #AuthenticatedData
                        )

                        this->ReceiveSequenceNumber += 1

                        Packet->Seek(Packet->GetOffset("TLS::RecordProtocol::Record") + #RecordHeader + Prepend)

                        ;Print("Decrypted Message:\n%hexdump\n", Body + Prepend, Header->Length - Prepend - Append)
                    }
                }


                INetworkLayer* Handler := this->ContentTypeHandlers->GetPointer((Type As i32) & 0xFF)

                if (Handler) {
                    Handler->Process(Packet)
                }
                else {
                    ;this->ContentTypeHandlers->Print()

                    Print("\n^S9No handler for content type %i (%s)^R\n", Type, nameof:(Type))
                    Exit(0)
                }

                Packet->Seek(Packet->GetEndOffset("TLS::RecordProtocol::Record"))

                ;Print("%x/%x\n", Packet->Offset, Packet->Size)

                ;break
            }
        }

        define void New(INetworkLayer* Base) {
            this->Base := Base

            this->ContentTypeHandlers := new AVLTree(#void*)
        }
    }
}

define void DoPrintDump(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
    i8* Buffer := Parameters[*ParameterIndex] As void*
    i32 Size := Parameters[*ParameterIndex + 1] As i32

    for (i32 Index := 0, Index < Size, Index++) {
        this->Print("%B", Buffer[Index])

        if (Index + 1 != Size) {
            this->Print(" ")
        }
    }

    *ParameterIndex += 2
}

PrintFormatPrototype DumpPrintPrototype {
    Name: "dump",
    Format: &DoPrintDump
}

i32 DUMP_PRINT_PROTOTYPE_ID := AddPrintFormat(&DumpPrintPrototype)