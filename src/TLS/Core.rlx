
interface INetworkOptions {

}

interface INetworkLayer {
    virtual NetworkPacket* Enter() {
        return null
    }
    virtual void Leave(NetworkPacket* Packet) {

    }

    virtual void Process(NetworkPacket*)
}

namespace TLS {
    enum VersionNumber As i32 {
        SSL_3_0 := 0x0300
        TLS_1_0 := 0x0301
        TLS_1_1 := 0x0302
        TLS_1_2 := 0x0303
        TLS_1_3 := 0x0304

        define i8 Major() {
            return ((this As i32) >> 8) As i8
        }
        define i8 Minor() {
            return ((this As i32) & 0xFF) As i8
        }
    }

    enum CipherSuite As i16 {
        Invalid := 0x0000
        RSA_WITH_AES_128_GCM_SHA256 := 0x9C00
        ECDHE_RSA_WITH_AES_128_GCM_SHA256 := 0x2FC0
        ECDH_RSA_WITH_AES_128_SHA256 := 0x31C0
    }

    namespace Security {
        interface ICertificate {
            virtual void* GetCertificateData(i32*)
            virtual void* GetPublicKey(i32*)

            virtual void* Sign(void*, i32, i32*)
        }

        interface IPseudoRandomFunction {
            virtual void* Generate(void* Key, i32 Size, i8* Label, void* Seed, i32 SeedSize, i32 NeededBytes)
            virtual void* GenerateMasterSecret(void* Key, i32 Size, i8* Label, i32 NeededBytes)
            virtual void* GenerateKeyMaterial(void* Key, i32 Size, i8* Label, i32 NeededBytes)
        }

        interface ICipherSuite {
            virtual ::IHashFunction* GetHashFunction()
            virtual IPseudoRandomFunction* GetPseudoRandomFunction()

            virtual i32 CalculateLeadingCipherTextSize() {
                return 0
            }
            virtual i32 CalculateFollowingCipherTextSize(void* Data, i32 Size) {
                return 0
            }

            virtual void Encrypt(void*, i32, void*, i32)
            virtual void Decrypt(void*, i32, void*, i32)
        }
    }
}