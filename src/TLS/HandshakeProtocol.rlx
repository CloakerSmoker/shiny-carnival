
#Require "./src/ASN1/Core.rlx"

namespace TLS::HandshakeProtocol {
    enum MessageType As i8 {
        HelloRequest := 0
        ClientHello := 1
        ServerHello := 2
        Certificate := 11
        ServerKeyExchange := 12
        CertificateRequest := 13
        ServerHelloDone := 14
        CertificateVerify := 15
        ClientKeyExchange := 16
        Finished := 20
    }

    struct ProtocolVersion {
        i8 Major
        i8 Minor
    }

    struct HandshakeRecord {
        bits As i32 {
            MessageType [0:7] Type
            [8:31] Length
        }
    }

    class Layer implements INetworkLayer, derives INew {
        TLS::RecordProtocol::Layer* Base

        define NetworkPacket* Enter(MessageType Type) {
            ;Print("Handshake Layer Entering %s\n", nameof:(Type))

            NetworkPacket* Packet := this->Base->Enter(RecordProtocol::ContentType::Handshake)
            HandshakeRecord* Record := Packet->Mark("TLS::HandshakeProtocol::Record", #HandshakeRecord)

            Record->Type := Type

            Packet->Mark("TLS::HandshakeProtocol::Data", 0)

            return Packet
        }

        PointerArray* Messages

        define void RecordMessage(void* Data, i32 Size) {
            Data += 0
            Size += 4

            ;Print("Recording Handshake Message of size %i\n", Size)

            this->Messages->Push(new NetworkPacket(CloneMemory(Data, Size), Size))
        }

        define void Leave(NetworkPacket* Packet) {
            HandshakeRecord* Record := Packet->Get("TLS::HandshakeProtocol::Record")

            i32 Start := Packet->GetOffset("TLS::HandshakeProtocol::Record")
            i32 Size := (Packet->Offset - Start) - #HandshakeRecord

            Packet->Extend("TLS::HandshakeProtocol::Data", Size)

            Record->Length := Swap32(Size) >> 8

            this->RecordMessage(Packet->Get("TLS::HandshakeProtocol::Record"), Size)

            this->Base->Leave(Packet)
        }

        AVLTree* MessageTypeHandlers ; <INetworkLayer*>

        define void RegisterMessageType(MessageType Type, INetworkLayer* Handler) {
            this->MessageTypeHandlers->InsertPointer((Type As i32) & 0xFF, Handler)
        }
        
        define void Process(NetworkPacket* Packet) {
            HandshakeRecord* Record := Packet->Mark("TLS::HandshakeProtocol::Record", #HandshakeRecord)

            i32 Length := 0

            if (Record->Length != 0) {
                Length := Swap32(Record->Length << 8)
            }

            Packet->Mark("TLS::HandshakeProtocol::Data", Length)

            this->RecordMessage(Packet->Get("TLS::HandshakeProtocol::Record"), Length)

            Record->Length := Length

            Packet->Seek(Packet->GetOffset("TLS::HandshakeProtocol::Data"))

            ;Print("Fixed Length: %x/%i\n", Record->Length, Record->Length)

            ;Packet->DumpMarkers()

            MessageType Type := Record->Type

            INetworkLayer* Handler := this->MessageTypeHandlers->GetPointer((Type As i32) & 0xFF)

            if (Handler != null) {
                Print("Handshake Layer Received %s\n", nameof:(Type))
                Handler->Process(Packet)
            }
            else {
                Print("No handler for message type %x (%s)\n", Type, nameof:(Type))
                Exit(0)
            }

            ;Packet->DumpMarkers()

            Packet->Seek(Packet->GetEndOffset("TLS::HandshakeProtocol::Record"))
        }

        define void New(RecordProtocol::Layer* Base) {
            this->Base := Base

            this->MessageTypeHandlers := new AVLTree(#void*)
            this->Messages := new PointerArray()
        }
    }

    struct CipherSuiteList {
        i16 Length

        union {
            CipherSuite[0] Suites
            i8[0] Data
        }

        define void* End() {
            return this->Data + ((this->Length As i32) & 0xFFFF)
        }

        define void Swap() {
            this->Length := Swap16(this->Length)
        }

        static self* New() {
            return Alloc(#self)
        }
    }

    enum CompressionMethod As i8 {
        Null := 0
        Deflate := 1
    }

    struct CompressionMethodList {
        i8 Length

        union {
            CompressionMethod[0] Methods
            i8[0] Data
        }

        define void* End() {
            return this->Data + ((this->Length As i32) & 0xFF)
        }

        static self* New() {
            return Alloc(#self)
        }
    }

    enum ExtensionType As i16 {
        ServerName := 0
        SupportedGroups := 10
        ECPointFormats := 11
        SignatureAlgorithms := 13
        Heartbeat := 15
        ApplicationLayerProtocolNegotiation := 16
        Padding := 21
        EncryptThenMAC := 22
        ExtendedMasterSecret := 23
        SessionTicket := 35
        SupportedVersions := 43
        PreSharedKeyExchangeModes := 45
        PostHandshakeAuth := 49
        KeyShare := 51
    }

    struct ExtensionEntry {
        ExtensionType Type
        i16 Length
        i8[0] Data

        define void* End() {
            return this->Data + ((this->Length As i32) & 0xFFFF)
        }

        define void Swap() {
            this->Type := Swap16(this->Type As i16) As ExtensionType
            this->Length := Swap16(this->Length)
        }

        static self* New() {
            return Alloc(#self)
        }
    }

    struct ExtensionList {
        i16 Length

        union {
            i8[0] Data
        }

        define void* End() {
            return this->Data + ((this->Length As i32) & 0xFFFF)
        }

        define void Swap() {
            this->Length := Swap16(this->Length)
        }

        define void* Find(ExtensionType Type) {
            ExtensionEntry* Entry := this->Data As void*

            while (Entry < this->End()) {
                if (Entry->Type = Type) {
                    return Entry
                }
            }

            return null
        }

        static self* New() {
            return Alloc(#self)
        }
    }

    struct ClientHelloRecord {
        ProtocolVersion Version
        i8[32] Random
        i8 SessionIDLength

        i8[0] Data
        
        define void* GetSessionIDTail() {
            return this->Data + ((this->SessionIDLength As i32) & 0xFF)
        }
        define CipherSuiteList* GetCipherSuites() {
            return this->GetSessionIDTail()
        }
        define CompressionMethodList* GetCompressionMethods() {
            return this->GetCipherSuites()->End()
        }
        define ExtensionList* GetExtensions() {
            return this->GetCompressionMethods()->End()
        }

        define ExtensionEntry* FindExtension(ExtensionType Type) {
            return this->GetExtensions()->Find(Type)
        }
    }

    struct ByteList {
        i8 Length
        i8[0] Bytes

        static void Append(ByteList** pThis, i8 Value) {
            ByteList* this := *pThis

            i32 Index := this->Length++
            this := ReAlloc(this, #self + this->Length)

            this->Bytes[Index] := Value

            *pThis := this
        }

        static self* New() {
            return Alloc(#self)
        }
    }

    struct WordList {
        i16 Length
        i16[0] Words

        define i32 Swap() {
            i32 Count := this->Length / 2

            for (i32 Index := 0, Index < Count, Index++) {
                this->Words[Index] := Swap16(this->Words[Index])
            }

            this->Length := Swap16(this->Length)

            return (Count + 1) * 2
        }

        static void Append(WordList** pThis, i16 Value) {
            WordList* this := *pThis

            i32 Index := this->Length / 2
            this->Length += 2

            this := ReAlloc(this, #self + this->Length)

            this->Words[Index] := Value

            *pThis := this
        }

        static self* New() {
            return Alloc(#self)
        }
    }

    enum SignatureAlgorithm As i16 {
        Ed25519 := 0x0807
        Ed448 := 0x0808
        RSA_PKCS1_SHA256 := 0x0401
        RSA_PKCS1_SHA512 := 0x0601
    }

    enum NamedCurve As i16 {
        x25519 := 0x1d
        x448 := 0x1e
    }

    enum ECPointFormat As i8 {
        Uncompressed := 0
    }

    #Require "./src/TLS/HandshakeProtocol/ServerName.rlx"

    class ClientHelloHelper derives INew {
        ProtocolVersion Version

        define void SetVersion(VersionNumber Version) {
            this~>Version->Major := Version.Major()
            this~>Version->Minor := Version.Minor()
        }
        
        i8[32] Random
        CipherSuiteList* CipherSuites
        CompressionMethodList* CompressionMethods
        PointerArray* Extensions

        ServerNameBuilder* ServerNames

        WordList* SignatureAlgorithms
        WordList* SupportedGroups
        ByteList* ECPointFormats

        define void New(TLS::VersionNumber Version) {
            this->CipherSuites := new CipherSuiteList()
            this->CompressionMethods := new CompressionMethodList()
            this->Extensions := new PointerArray()

            this->SetVersion(Version)
        }

        define void SetRandom(void* Random) {
            MoveMemory(this->Random, Random, 32)
        }

        define void AddCipherSuite(CipherSuite Suite) {
            i32 Index := this->CipherSuites->Length
            this->CipherSuites->Length += 1

            this->CipherSuites := ReAlloc(this->CipherSuites, (this->CipherSuites->Length * 2) + #CipherSuiteList)

            this->CipherSuites->Suites[Index] := Suite
        }
        define void AddCompressionMethod(CompressionMethod Method) {
            i32 Index := this->CompressionMethods->Length
            this->CompressionMethods->Length += 1

            this->CompressionMethods := ReAlloc(this->CompressionMethods, this->CompressionMethods->Length + #CompressionMethodList)

            this->CompressionMethods->Methods[Index] := Method
        }

        define void AddExtension(ExtensionType Type, void* Data, i32 Size) {
            ExtensionEntry* Entry := Alloc(Size + #ExtensionEntry)

            Entry->Type := Type
            Entry->Length := Size As i16

            if (Size) {
                MoveMemory(Entry->Data, Data, Size)
            }

            this->Extensions->Push(Entry)
        }
        define void AddExtension(ExtensionType Type) {
            this->AddExtension(Type, null, 0)
        }

        define void AddServerHostName(i8* Name) {
            if !(this->ServerNames) {
                this->ServerNames := new ServerNameBuilder()
            }

            this->ServerNames->AddHostName(Name)
        }

        define void AddSignatureAlgorithm(SignatureAlgorithm Algorithm) {
            if !(this->SignatureAlgorithms) {
                this->SignatureAlgorithms := new WordList()
            }

            WordList:Append(this~>SignatureAlgorithms, Algorithm As i16)
        }

        define void AddSupportedGroup(NamedCurve Group) {
            if !(this->SupportedGroups) {
                this->SupportedGroups := new WordList()
            }

            WordList:Append(this~>SupportedGroups, Group As i16)
        }

        define void AddPointFormat(ECPointFormat Format) {
            if !(this->ECPointFormats) {
                this->ECPointFormats := new ByteList()
            }
            
            ByteList:Append(this~>ECPointFormats, Format As i8)
        }

        define NetworkPacket* Write(NetworkPacket* Packet) {
            if (this->ServerNames) {
                i32 ServerNamesSize := 0
                void* ServerNamesData := this->ServerNames->Build(&ServerNamesSize)

                this->AddExtension(ExtensionType::ServerName, ServerNamesData, ServerNamesSize)
            }

            if (this->SignatureAlgorithms) {
                i32 Size := this->SignatureAlgorithms->Swap()

                this->AddExtension(ExtensionType::SignatureAlgorithms, this->SignatureAlgorithms, Size)
            }

            if (this->SupportedGroups) {
                i32 Size := this->SupportedGroups->Swap()

                this->AddExtension(ExtensionType::SupportedGroups, this->SupportedGroups, Size)
            }

            if (this->ECPointFormats) {
                this->AddExtension(ExtensionType::ECPointFormats, this->ECPointFormats, #ByteList + this->ECPointFormats->Length)
            }


            i32 Size := #ClientHelloRecord

            Size += (this->CipherSuites->Length * 2) + #CipherSuiteList
            Size += this->CompressionMethods->Length + #CompressionMethodList
            Size += 2 ;#ExtensionList

            i32 ExtensionDataSize := 0

            for (i32 Index := 0, Index < this->Extensions->Length, Index++) {
                ExtensionEntry* Entry := this->Extensions->At(Index)

                ExtensionDataSize += Entry->Length + #ExtensionEntry

                ;Print("Extension %i needs %i bytes\n", Index, Entry->Length + #ExtensionEntry)
            }

            Size += ExtensionDataSize

            ClientHelloRecord* Record := Packet->Mark("TLS::HandshakeProtocol::ClientHelloRecord", Size)

            MoveMemory(Record->Random, this->Random, 32)
            MoveMemory(Record~>Version, this~>Version, #ProtocolVersion)

            Record->SessionIDLength := 0

            i32 CipherSuitesSize := this->CipherSuites->Length * 2
            CipherSuiteList* CipherSuites := Record->GetCipherSuites()
            MoveMemory(CipherSuites, this->CipherSuites, #CipherSuiteList + CipherSuitesSize)
            CipherSuites->Length := CipherSuitesSize As i16

            MoveMemory(Record->GetCompressionMethods(), this->CompressionMethods, this->CompressionMethods->Length + #CompressionMethodList)
            
            ExtensionList* Extensions := Record->GetExtensions()
            ExtensionEntry* CurrentEntry := Extensions->Data As void*
            i32 Count := this->Extensions->Count()

            for (i32 Index := 0, Index < Count, Index++) {
                ExtensionEntry* SourceEntry := this->Extensions->At(Index)
                i32 EntrySize := #ExtensionEntry + SourceEntry->Length

                ;Print("Extension %i at offset %i\n", Index, (CurrentEntry As i64) - (Extensions~>FirstEntry As i64))

                MoveMemory(CurrentEntry, SourceEntry, EntrySize)
                ExtensionEntry* NextEntry := CurrentEntry->End()

                CurrentEntry->Swap()

                CurrentEntry := NextEntry
            }

            CipherSuites->Length := Swap16(CipherSuites->Length)
            Extensions->Length := Swap16(ExtensionDataSize As i16)

            return Packet
        }

        define void Read(NetworkPacket* Packet) {
            ClientHelloRecord* Record := Packet->Mark("TLS::HandshakeProtocol::ClientHelloRecord", #ClientHelloRecord)

            MoveMemory(this->Random, Record->Random, 32)

            Packet->AssertBound(Record->SessionIDLength + #CipherSuiteList)
            Packet->Mark("TLS::HandshakeProtocol::ClientHello::SessionID", (Record->SessionIDLength As i32) & 0xFF)

            CipherSuiteList* CipherSuites := Record->GetCipherSuites()

            CipherSuites->Swap()

            i32 CipherSuitesSize := (CipherSuites->Length As i32) & 0xFFFF
            i32 CipherSuiteCount := CipherSuitesSize / 2

            Packet->AssertBound(CipherSuitesSize + #CompressionMethodList)
            Packet->Mark("TLS::HandshakeProtocol::ClientHello::CipherSuites", #CipherSuiteList + CipherSuitesSize)


            for (i32 Index := 0, Index < CipherSuiteCount, Index++) {
                this->AddCipherSuite(Swap16(CipherSuites->Suites[Index] As i16) As CipherSuite)
            }

            CompressionMethodList* CompressionMethods := Record->GetCompressionMethods()

            Print("Compression methods list:\n%hexdump\n", CompressionMethods, 0x20)

            Print("Compression Methods Length: %i\n", (CompressionMethods->Length As i32) & 0xFF)

            i32 CompressionMethodsSize := (CompressionMethods->Length As i32) & 0xFF

            Packet->AssertBound(CompressionMethodsSize + #ExtensionList)
            Packet->Mark("TLS::HandshakeProtocol::ClientHello::CompressionMethods", CompressionMethodsSize + #CompressionMethodList)

            for (i32 Index := 0, Index < CompressionMethodsSize, Index++) {
                this->AddCompressionMethod(CompressionMethods->Methods[Index])
            }

            ExtensionList* Extensions := Record->GetExtensions()

            Extensions->Swap()

            Print("Extensions Length: %i\n", (Extensions->Length As i32) & 0xFFFF)

            Packet->AssertBound(Extensions->Length)
            Packet->Mark("TLS::HandshakeProtocol::ClientHello::Extensions", #ExtensionList + (Extensions->Length As i32) & 0xFFFF)
            Packet->Seek(Packet->GetOffset("TLS::HandshakeProtocol::ClientHello::Extensions") + #ExtensionList)

            ExtensionEntry* Entry := null
            
            i32 End := Packet->Tell() + ((Extensions->Length As i32) & 0xFFFF)

            while (Packet->Tell() < End) {
                Packet->AssertBound(#ExtensionEntry)

                ExtensionEntry* Entry := Packet->Bump(#ExtensionEntry)
                Entry->Swap()

                i32 Length := (Entry->Length As i32) & 0xFFFF

                Print("Extension Type: %x Length: %i\n", Entry->Type, Length)

                Packet->AssertBound(Length)
                Packet->Bump(Length)

                this->AddExtension(Entry->Type, Entry->Data, Length)
            }

            Packet->DumpMarkers()


            
        }
    }

    struct ServerHelloRecordTail {
        CipherSuite Cipher
        CompressionMethod Compression

        ExtensionList Extensions
    }

    struct ServerHelloRecord {
        ProtocolVersion Version
        i8[32] Random
        i8 SessionIDLength

        i8[0] Data
        
        define void* GetSessionIDTail() {
            return this->Data + ((this->SessionIDLength As i32) & 0xFF)
        }
        define ServerHelloRecordTail* GetTail() {
            return this->GetSessionIDTail()
        }

        define CipherSuite GetCipherSuite() {
            return this->GetTail()->Cipher
        }
        define CompressionMethod GetCompressionMethod() {
            return this->GetTail()->Compression
        }
        define ExtensionList* GetExtensions() {
            return this->GetTail()~>Extensions
        }
    }

    

    class ServerHelloHelper derives INew {
        ProtocolVersion Version

        define void SetVersion(VersionNumber Version) {
            this~>Version->Major := Version.Major()
            this~>Version->Minor := Version.Minor()
        }

        i8[32] Random
        CipherSuite Cipher
        CompressionMethod Compression
        PointerArray* Extensions

        define void New() {
            this->Extensions := new PointerArray()
        }

        define void SetRandom(void* Random) {
            MoveMemory(this->Random, Random, 32)
        }
        define void SetCipherSuite(CipherSuite Cipher) {
            this->Cipher := Cipher
        }
        define void SetCompressionMethod(CompressionMethod Compression) {
            this->Compression := Compression
        }

        define void AddExtension(ExtensionType Type, void* Data, i32 Size) {
            ExtensionEntry* Entry := Alloc(Size + #ExtensionEntry)

            Entry->Type := Type
            Entry->Length := Size As i16

            MoveMemory(Entry->Data, Data, Size)

            this->Extensions->Push(Entry)
        }

        define void Write(NetworkPacket* Packet) {
            i32 Size := #ServerHelloRecord

            Size += #ServerHelloRecordTail

            for (i32 Index := 0, Index < this->Extensions->Length, Index++) {
                ExtensionEntry* Entry := this->Extensions->At(Index)

                Size += Entry->Length + #ExtensionEntry
            }

            ServerHelloRecord* Record := Packet->Mark("TLS::HandshakeProtocol::ServerHelloRecord", Size)

            MoveMemory(Record->Random, this->Random, 32)

            Record->SessionIDLength := 0

            ServerHelloRecordTail* Tail := Record->GetTail()

            Tail->Cipher := this->Cipher
            Tail->Compression := this->Compression

            ExtensionList* Extensions := Tail~>Extensions
            i32 Count := this->Extensions->Count()

            for (i32 Index := 0, Index < Count, Index++) {
                ExtensionEntry* Entry := this->Extensions->At(Index)
                i32 EntrySize := Entry->Length + #ExtensionEntry

                MoveMemory(Extensions->End(), Entry, EntrySize)
                Extensions->Length += EntrySize As i16
            }

            ExtensionList* Extensions := Record->GetExtensions()
            Extensions->Length := Swap16(Extensions->Length)

            return Packet
        }

        define void Read(NetworkPacket* Packet) {
            ServerHelloRecord* Record := Packet->Mark("TLS::HandshakeProtocol::ServerHelloRecord", #ServerHelloRecord)
            ServerHelloRecordTail* Tail := Record->GetTail()

            i32 Size := Record->SessionIDLength + #ServerHelloRecordTail

            Packet->Extend("TLS::HandshakeProtocol::ServerHelloRecord", Size)

            MoveMemory(this->Random, Record->Random, 32)
            this->Cipher := Tail->Cipher
            this->Compression := Tail->Compression

            ExtensionList* Extensions := Tail~>Extensions

            Extensions->Length := Swap16(Extensions->Length)

            void* ExtensionsEnd := Extensions->End()
            ExtensionEntry* Entry := Extensions->Data As void*

            while (Entry < ExtensionsEnd) {
                this->Extensions->Push(Entry)
                Entry->Swap()

                Entry := Entry->End()
            }
        }
    }

    enum CurveType As i8 {
        Named := 0x3
    }

    struct ServerKeyExchangeRecord unaligned {
        CurveType Type
        NamedCurve Curve
        i8 PublicKeyLength
        i8[0] PublicKey

        define ServerKeyExchangeRecordTail* GetTail() {
            return (this->PublicKey + ((this->PublicKeyLength As i32) & 0xFF)) As void*
        }
    }

    struct ServerKeyExchangeRecordTail {
        SignatureAlgorithm Algorithm
        i16 SignatureLength
        i8[0] Signature
    }

    class ServerKeyExchangeHelper derives INew {
        CurveType Type
        NamedCurve Curve

        i32 PublicKeyLength
        i8* PublicKey

        SignatureAlgorithm Algorithm

        i32 SignatureLength
        i8* Signature

        define void Read(NetworkPacket* Packet) {
            ServerKeyExchangeRecord* Record := Packet->Mark("TLS::HandshakeProtocol::ServerKeyExchangeRecord", #ServerKeyExchangeRecord)
            ServerKeyExchangeRecordTail* Tail := Record->GetTail()

            this->PublicKeyLength := Record->PublicKeyLength
            this->SignatureLength := (Swap16(Tail->SignatureLength) As i32) & 0xFFFF

            i32 Size := this->PublicKeyLength + #ServerKeyExchangeRecordTail + this->SignatureLength

            Packet->Extend("TLS::HandshakeProtocol::ServerKeyExchangeRecord", Size)

            this->Type := Record->Type
            this->Curve := Swap16(Record->Curve As i16) As NamedCurve
            this->PublicKey := CloneMemory(Record->PublicKey, this->PublicKeyLength)
            this->Algorithm := Swap16(Tail->Algorithm As i16) As SignatureAlgorithm
            this->Signature := CloneMemory(Tail->Signature, this->SignatureLength)
        }
    }

    struct CertificateRecord {
        i8[3] LengthBytes ; Are you serious?

        define i32 GetLength() {
            i32 Low := (this->LengthBytes[2] As i32) & 0xFF
            i32 Mid := (this->LengthBytes[1] As i32) & 0xFF
            i32 High := (this->LengthBytes[0] As i32) & 0xFF

            return (High << 16) | (Mid << 8) | Low
        }
    }

    class CertificateHelper derives INew {
        PointerArray* CertificatesData ; <NetworkPacket*>

        define void New() {
            this->CertificatesData := new PointerArray()
        }

        define void Read(NetworkPacket* Packet) {
            CertificateRecord* Record := Packet->Mark("TLS::HandshakeProtocol::CertificateRecord", #CertificateRecord)

            i32 Length := Record->GetLength()

            Print("Certificates Length: %x\n", Length)

            Packet->AssertBound(Length)
            Packet->Mark("TLS::HandshakeProtocol::CertificateRecord::Data", Length)
            Packet->Seek(Packet->GetOffset("TLS::HandshakeProtocol::CertificateRecord::Data"))

            i32 End := Packet->Tell() + Length

            while (Packet->Tell() < End) {
                Packet->AssertBound(#CertificateRecord)
                CertificateRecord* Record := Packet->Bump(#CertificateRecord)

                Packet->AssertBound(Record->GetLength())
                void* Data := Packet->Bump(Record->GetLength())
                
                this->CertificatesData->Push(new NetworkPacket(CloneMemory(Data, Record->GetLength()), Record->GetLength()))
            }

            i32 Count := this->CertificatesData->Count()

            for (i32 Index := 0, Index < Count, Index++) {
                NetworkPacket* CertificatePacket := this->CertificatesData->At(Index)

                ASN1::DER::Parser* Parser := new ASN1::DER::Parser(CertificatePacket->Buffer, CertificatePacket->Size)

                ASN1::DER::IValue* RawCertificate := Parser->ParseValue()

                if !(RawCertificate->Is(ASN1::DER::UniversalTag::SEQUENCE)) {
                    Print("Certificate is not a sequence\n")
                    Exit(0)
                }

                ASN1::DER::SequenceValue* Certificate := RawCertificate As ASN1::DER::SequenceValue*

                if (Certificate->Count() != 3) {
                    Print("Certificate sequence does not have 3 items\n")
                    Exit(0)
                }

                ASN1::DER::IValue* RawTBS := Certificate->At(0)

                if !(RawTBS->Is(ASN1::DER::UniversalTag::SEQUENCE)) {
                    Print("Certificate TBS is not a sequence\n")
                    Exit(0)
                }

                ASN1::DER::SequenceValue* TBS := RawTBS As ASN1::DER::SequenceValue*

                if (TBS->Count() < 7) {
                    Print("Certificate TBS sequence has less than 7 items\n")
                    Exit(0)
                }

                ASN1::DER::IValue* RawVersion := TBS->At(0)

                if !(RawVersion->GetClass() = ASN1::DER::IdentifierClass::CONTEXT_SPECIFIC && RawVersion->GetConstructed()) {
                    Print("Certificate version is not a context-specific sequence\n")
                    Exit(0)
                }

                ASN1::DER::SequenceValue* VersionSequence := RawVersion As ASN1::DER::SequenceValue*

                i32 VersionCount := VersionSequence->Count()

                for (i32 Index := 0, Index < VersionCount, Index++) {
                    ASN1::DER::IValue* Item := VersionSequence->At(Index)

                    if !(Item->Is(ASN1::DER::UniversalTag::INTEGER)) {
                        Print("Certificate version item %i is not an integer\n", Index)
                        Exit(0)
                    }
                }

                if (VersionCount != 1) {
                    Print("Certificate version sequence does not have exactly 1 item\n")
                    Exit(0)
                }

                ASN1::DER::IntegerValue* VersionValue := VersionSequence->At(0) As ASN1::DER::IntegerValue*
                
                if (VersionValue->Value->DigitCount != 1) {
                    Print("Certificate version integer is greater than %i\n", BIG_NUMBER_BASE)
                    Exit(0)
                }

                i32 Version := VersionValue->Value->Digits[0]

                Print("Certificate Version: %i\n", Version)

                ASN1::DER::IValue* RawSignatureAlgorithm := Certificate->At(1)
                ASN1::DER::IValue* SignatureValue := Certificate->At(2)

                Exit(0)

            }
        }
    }
}