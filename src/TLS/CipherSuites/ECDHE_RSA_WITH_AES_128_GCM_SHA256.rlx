namespace TLS::Security::ECDHE_RSA_WITH_AES_128_GCM_SHA256 {
    struct CurveInfo unaligned {
        CurveType Type
        NamedCurve Curve
        i8 PublicKeyLength
    }

    struct KeyBlock {
        i8[16] ClientEncryptionKey
        i8[16] ServerEncryptionKey
        i8[4] ClientIV
        i8[4] ServerIV
    }

    struct ClientKeyExchangeRecord {
        i8 PublicKeyLength
        i8[0] PublicKey
    }

    struct ServerKeyExchangeRecord unaligned {
        CurveType Type
        NamedCurve Curve
        i8 PublicKeyLength
        i8[0] PublicKey

        define ServerKeyExchangeRecordTail* GetTail() {
            return (this->PublicKey + ((this->PublicKeyLength As i32) & 0xFF)) As void*
        }
    }

    struct ServerKeyExchangeRecordTail {
        SignatureAlgorithm Algorithm
        i16 SignatureLength
        i8[0] Signature
    }

    class Suite implements ICipherSuite, derives INew {
        SecurityParameters* Parameters

        ; Suite parameters
        NamedCurve CurveName
        SignatureAlgorithm SigningAlgorithm

        ; Components
        SHA2_256* Hash
        HMACWrapper* HMAC
        TLS_1_2_PRF* PRF
        AES_GCM* BulkCipher

        RFC7748::ICurve* Curve
        i32 PublicKeyLength

        define IHashFunction* GetHashFunction() {
            return this->Hash
        }
        define IPseudoRandomFunction* GetPseudoRandomFunction() {
            return this->PRF
        }

        define void New(SecurityParameters* Parameters) {
            this->Parameters := Parameters
        }

        define void SetCurve(NamedCurve Curve) {
            this->CurveName := Curve

            if (Curve = NamedCurve::x25519) {
                this->Curve := new RFC7748::Curve25519()
            }
            else if (Curve = NamedCurve::x448) {
                this->Curve := new RFC7748::Curve448()
            }
            else {
                Throw(new FatalAlert(AlertDescription::HandshakeFailure, "Unsupported curve"))
            }

            this->PublicKeyLength := this->Curve->GetScalarSize()
            this->Parameters->LocalPrivateKey := AllocateSecureRandom(this->PublicKeyLength)

            BigInteger* PrivateKey := BigInteger:FromBytes(this->Parameters->LocalPrivateKey, this->PublicKeyLength)
            BigInteger* PrivateKeyScalar := this->Curve->PrepareScalar(PrivateKey)

            BigInteger* LocalPublicKey := this->Curve->Multiply(new BigInteger(9), PrivateKeyScalar->Reference())

            i8* LocalPublicKeyBytes := Alloc(this->PublicKeyLength)

            for (i32 Index := 0, Index < this->PublicKeyLength, Index++) {
                LocalPublicKeyBytes[Index] := LocalPublicKey->GetByte(Index) As i8
            }

            this->Parameters->Local->PublicKey := LocalPublicKeyBytes
        }

        define void SendServerExtensions(HandshakeProtocol::ExtensionList* ClientExtensions, HandshakeProtocol::ExtensionList* ServerExtensions) {
            if !(ClientExtensions->Has(HandshakeProtocol::ExtensionType::SignatureAlgorithms)) {
                Throw(new FatalAlert(AlertDescription::HandshakeFailure, "Client did not provide supported signature algorithms extension"))
            }

            HandshakeProtocol::ExtensionEntry* SignatureAlgorithmsEntry := ClientExtensions->Get(HandshakeProtocol::ExtensionType::SignatureAlgorithms)

            i32 Count := SignatureAlgorithmsEntry->Length / 2
            i16* RawSignatureAlgorithms := SignatureAlgorithmsEntry->Data As i16*

            for (i32 Index := 0, Index < Count, Index++) {
                SignatureAlgorithm Algorithm := Swap16(RawSignatureAlgorithms[Index]) As SignatureAlgorithm
                
                if (Algorithm = SignatureAlgorithm::RSA_PKCS1_SHA256) {
                    this->SigningAlgorithm := SignatureAlgorithm::RSA_PKCS1_SHA256
                    break
                }
            }

            if (this->SigningAlgorithm = SignatureAlgorithm::Invalid) {
                Throw(new FatalAlert(AlertDescription::HandshakeFailure, "Client does not support required signature algorithm"))
            }


            if !(ClientExtensions->Has(HandshakeProtocol::ExtensionType::SupportedGroups)) {
                Throw(new FatalAlert(AlertDescription::HandshakeFailure, "Client did not require supported groups extension"))
            }

            i16[2] SupportedGroups
            SupportedGroups[0] := Swap16(2)
            SupportedGroups[1] := Swap16(NamedCurve::x25519 As i16)

            ServerExtensions->Add(
                HandshakeProtocol::ExtensionType::SupportedGroups,
                SupportedGroups,
                4
            )

            this->SetCurve(NamedCurve::x25519) ; TODO: Choose based on client support

            if !(ClientExtensions->Has(HandshakeProtocol::ExtensionType::ECPointFormats)) {
                Throw(new FatalAlert(AlertDescription::HandshakeFailure, "Client did not require EC point formats extension"))
            }

            i8[2] ECPointFormats
            ECPointFormats[0] := 1
            ECPointFormats[1] := ECPointFormat::Uncompressed As i8

            ServerExtensions->Add(
                HandshakeProtocol::ExtensionType::ECPointFormats,
                ECPointFormats,
                2
            )
        }

        define void ReceiveServerExtensions(HandshakeProtocol::ExtensionList* ServerExtensions) {
            ; TODO
        }

        declare void GenerateKeys()

        define void SendServerKeyExchange(NetworkPacket* Packet) {
            ServerKeyExchangeRecord* Record := Packet->Mark("TLS::HandshakeProtocol::KeyExchange", #ServerKeyExchangeRecord)

            Record->Type := CurveType::Named
            Record->Curve := Swap16(this->CurveName As i16) As NamedCurve

            i32 ScalarSize := this->Curve->GetScalarSize()

            this->Parameters->Server->PublicKey := AllocateSecureRandom(ScalarSize)

            Packet->Mark("TLS::HandshakeProtocol::KeyExchange::PublicKey", ScalarSize)

            Record->PublicKeyLength := ScalarSize As i8
            MoveMemory(Record->PublicKey, this->Parameters->Server->PublicKey, ScalarSize)

            Packet->Mark("TLS::HandshakeProtocol::KeyExchange::Tail", #ServerKeyExchangeRecordTail)
            ServerKeyExchangeRecordTail* Tail := Record->GetTail()

            Tail->Algorithm := Swap16(this->SigningAlgorithm As i16) As SignatureAlgorithm

            void* SignatureData := Alloc(32 + 32 + 3 + ScalarSize)

            MoveMemory(SignatureData, this->Parameters->Client->Random, 32)
            MoveMemory(SignatureData + 32, this->Parameters->Server->Random, 32)
            CurveInfo Info {
                Type: CurveType::Named,
                Curve: Swap16(this->CurveName As i16) As NamedCurve,
                PublicKeyLength: ScalarSize As i8
            }
            MoveMemory(SignatureData + 64, &Info, #CurveInfo)
            MoveMemory(SignatureData + 64 + #CurveInfo, Record->PublicKey, ScalarSize)

            Print("Signature Data:\n%hexdump\n", SignatureData, 64 + #CurveInfo + ScalarSize)

            Print("Signature Data: ")

            for (i32 Index := 0, Index < 64 + #CurveInfo + ScalarSize, Index++) {
                Print("%B", (SignatureData As i8*)[Index])
            }

            Print("\n")

            i32 SignatureLength := 0
            void* Signature := this->Parameters->Certificate->Sign(
                SignatureData,
                64 + #CurveInfo + ScalarSize,
                &SignatureLength
            )

            Packet->Mark("TLS::HandshakeProtocol::KeyExchange::Signature", SignatureLength)

            Tail->SignatureLength := Swap16(SignatureLength As i16) As i16
            MoveMemory(Tail->Signature, Signature, SignatureLength)
        }

        define void ReceiveServerKeyExchange(NetworkPacket* Packet) {
            Packet->AssertBound(#ServerKeyExchangeRecord)
            ServerKeyExchangeRecord* Record := Packet->Mark("TLS::HandshakeProtocol::KeyExchange", #ServerKeyExchangeRecord)

            this->SetCurve(Swap16(Record->Curve As i16) As NamedCurve)

            i32 PublicKeyLength := (Record->PublicKeyLength As i32) & 0xFF
            Packet->AssertBound(PublicKeyLength)

            this->Parameters->Remote->PublicKeyLength := PublicKeyLength

            void* PublicKey := Packet->Mark("TLS::HandshakeProtocol::KeyExchange::PublicKey", PublicKeyLength)
            this->Parameters->Remote->PublicKey := CloneMemory(PublicKey, PublicKeyLength)

            Packet->AssertBound(#ServerKeyExchangeRecordTail)
            ServerKeyExchangeRecordTail* Tail := Record->GetTail()

            this->SigningAlgorithm := Swap16(Tail->Algorithm As i16) As SignatureAlgorithm
            i32 SignatureLength := Swap16(Tail->SignatureLength) As i32
            Packet->AssertBound(SignatureLength)

            void* Signature := Packet->Mark("TLS::HandshakeProtocol::KeyExchange::Signature", SignatureLength)

            ; TODO: Verify signature
        }

        define void ReceiveClientKeyExchange(NetworkPacket* Packet) {
            Packet->AssertBound(#ClientKeyExchangeRecord)
            ClientKeyExchangeRecord* Record := Packet->Mark("TLS::HandshakeProtocol::KeyExchange", #ClientKeyExchangeRecord)

            i32 PublicKeyLength := (Record->PublicKeyLength As i32) & 0xFF
            Packet->AssertBound(PublicKeyLength)

            if (PublicKeyLength != this->Curve->GetScalarSize()) {
                i8* Message := FormatString("Invalid public key length %i for curve %i\n", PublicKeyLength, this->CurveName)
                Throw(new FatalAlert(AlertDescription::IllegalParameter, Message))
            }

            void* PublicKey := Packet->Mark("TLS::HandshakeProtocol::KeyExchange::PublicKey", PublicKeyLength)
            this->Parameters->Remote->PublicKey := CloneMemory(PublicKey, PublicKeyLength)

            this->GenerateKeys()
        }

        define void SendClientKeyExchange(NetworkPacket* Packet) {
            ClientKeyExchangeRecord* Record := Packet->Mark("TLS::HandshakeProtocol::KeyExchange", #ClientKeyExchangeRecord)

            i32 PublicKeyLength := this->Curve->GetScalarSize()

            Record->PublicKeyLength := ((PublicKeyLength As i8) & 0xFF) As i8

            void* PublicKey := Packet->Mark("TLS::HandshakeProtocol::KeyExchange::PublicKey", PublicKeyLength)

            MoveMemory(PublicKey, this->Parameters->Local->PublicKey, PublicKeyLength)
        }

        define void SignEphemeralKey(void** OutSignature, i32* OutSignatureLength) {
            this->Hash->Prepare()
            this->Hash->Update(this->Parameters->Client->Random, 32)
            this->Hash->Update(this->Parameters->Server->Random, 32)
            
            CurveInfo Info {
                Type: CurveType::Named,
                Curve: this->CurveName
            }

            this->Hash->Update(&Info, #CurveInfo)
            this->Hash->Update(this->Parameters->Server->PublicKey, this->Parameters->Server->PublicKeyLength)

            i8[32] Digest
            this->Hash->Finalize(Digest)

            *OutSignature := this->Parameters->Certificate->Sign(Digest, 32, OutSignatureLength)
        }

        define void GenerateKeys() {
            i32 ScalarSize := this->Curve->GetScalarSize()

            BigInteger* RemotePublicKey := BigInteger:FromBytes(this->Parameters->Remote->PublicKey, ScalarSize)
            BigInteger* LocalPrivateKey := BigInteger:FromBytes(this->Parameters->LocalPrivateKey, ScalarSize)

            BigInteger* LocalPrivateKeyScalar := this->Curve->PrepareScalar(LocalPrivateKey)
            BigInteger* PreMasterSecret := this->Curve->Multiply(RemotePublicKey, LocalPrivateKeyScalar)

            i8* PreMasterSecretBytes := Alloc(ScalarSize)

            for (i32 Index := 0, Index < ScalarSize, Index++) {
                PreMasterSecretBytes[Index] := PreMasterSecret->GetByte(Index) As i8
            }

            this->Parameters->PreMasterSecret := PreMasterSecretBytes

            this->Hash := new SHA2_256()
            this->HMAC := new HMACWrapper(this->Hash)
            this->PRF := new TLS_1_2_PRF(this->Parameters, this->HMAC)
            this->BulkCipher := new AES_GCM(AESKeySize::128)

            this->Parameters->MasterSecret := this->PRF->GenerateMasterSecret(this->Parameters->PreMasterSecret, ScalarSize, "master secret", 48)

            Print("Master Secret:\n%hexdump\n", this->Parameters->MasterSecret, 48)

            this->Parameters->KeyBlock := this->PRF->GenerateKeyMaterial(this->Parameters->MasterSecret, 48, "key expansion", #KeyBlock)

            Print("Key Block:\n%hexdump\n", this->Parameters->KeyBlock, #KeyBlock)

            KeyBlock* Keys := this->Parameters->KeyBlock

            DirectionalKeySet* ClientKeys := this->Parameters~>Client
            DirectionalKeySet* ServerKeys := this->Parameters~>Server

            ClientKeys->EncryptionKey := Keys->ClientEncryptionKey
            ClientKeys->IV := Keys->ClientIV

            ServerKeys->EncryptionKey := Keys->ServerEncryptionKey
            ServerKeys->IV := Keys->ServerIV

            Print("Client Encryption Key:\n%hexdump\n", ClientKeys->EncryptionKey, 16)
            Print("Client IV:\n%hexdump\n", ClientKeys->IV, 4)

            Print("Server Encryption Key:\n%hexdump\n", ServerKeys->EncryptionKey, 16)
            Print("Server IV:\n%hexdump\n", ServerKeys->IV, 4)

            i64 KeyLogFile := FileOpen("rlxkeylog.log", FILE_CREATE_NEW | FILE_WRITE)

            FileSeek(KeyLogFile, 0, SEEK_END)

            FileWrite(KeyLogFile, "CLIENT_RANDOM ", 14)

            for (i32 Index := 0, Index < 32, Index++) {
                i8 Byte := (this->Parameters->Client->Random As i8*)[Index]
                i32 Upper := (Byte >> 4) & 0xF
                i32 Lower := Byte & 0xF
                FileWrite(KeyLogFile, "0123456789abcdef" + Upper, 1)
                FileWrite(KeyLogFile, "0123456789abcdef" + Lower, 1)
            }

            FileWrite(KeyLogFile, " ", 1)

            for (i32 Index := 0, Index < 48, Index++) {
                i8 Byte := (this->Parameters->MasterSecret As i8*)[Index]
                i32 Upper := (Byte >> 4) & 0xF
                i32 Lower := Byte & 0xF
                FileWrite(KeyLogFile, "0123456789abcdef" + Upper, 1)
                FileWrite(KeyLogFile, "0123456789abcdef" + Lower, 1)
            }

            FileWrite(KeyLogFile, "\n", 1)
            FileTruncate(KeyLogFile, FileTell(KeyLogFile))

            FileClose(KeyLogFile)
        }

        define i32 CalculateLeadingCipherTextSize() {
            return 8 ; prepend 8 byte explicit nonce
        }
        define i32 CalculateFollowingCipherTextSize(void* Data, i32 Size) {
            return 16 ; append 16 byte tag
        }

        define void Encrypt(void* Data, i32 DataLength, void* Authenticate, i32 AuthenticateLength) {
            this->BulkCipher->SetKey(this->Parameters->Local->EncryptionKey)

            i8[12] IV
            MoveMemory(IV, this->Parameters->Local->IV, 4)
            ;MoveMemory(IV + 4, "random 8", 8)
            
            SecureFillRandom(IV + 4, 8)

            MoveMemory(Data, IV + 4, 8) ; prepend explicit nonce

            ;Print("Nonce:\n%hexdump\n", IV, 12)

            this->BulkCipher->SetIV(IV, 12)
            this->BulkCipher->AuthenticateBytes(Authenticate, AuthenticateLength)
            this->BulkCipher->EncryptBytes(Data + 8, DataLength)

            this->BulkCipher->CalculateTag(Data + 8 + DataLength, 16)
        }
        define void Decrypt(void* Data, i32 DataLength, void* Authenticate, i32 AuthenticateLength) {
            ;Print("AAD:\n%hexdump\n", Authenticate, AuthenticateLength)

            this->BulkCipher->SetKey(this->Parameters->Remote->EncryptionKey)

            i8[12] IV
            MoveMemory(IV, this->Parameters->Remote->IV, 4)
            MoveMemory(IV + 4, Data, 8) ; prepend explicit nonce

            void* Tag := Data + DataLength - 16

            this->BulkCipher->SetIV(IV, 12)

            ;Print("Encrypted Data: \n%hexdump\n", Data + 8, DataLength - 8 - 16)

            this->BulkCipher->AuthenticateBytes(Authenticate, AuthenticateLength)
            this->BulkCipher->DecryptBytes(Data + 8, DataLength - 8 - 16)

            i8[16] CalculatedTag
            this->BulkCipher->CalculateTag(CalculatedTag, 16)

/*             Print("Message Tag   : ")
            for (i32 Index := 0, Index < 16, Index++) {
                Print("%B", (Tag As i8*)[Index])
            }
            Print("\n")

            Print("Calculated Tag: ")
            for (i32 Index := 0, Index < 16, Index++) {
                Print("%B", (CalculatedTag As i8*)[Index])
            }
            Print("\n") */

            if !(CompareMemory(Tag, CalculatedTag, 16)) {
                Print("Tag does not match\n")
                Exit(1)
            }
        }
    }
}