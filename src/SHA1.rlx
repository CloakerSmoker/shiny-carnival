
define void ZeroMemory(void* RawMemory, i32 Size) {
    i8* Memory := RawMemory

    for (i32 Index := 0, Index < Size, Index++) {
        Memory[Index] := 0
    }
}

define i32 Swap32(i32 Value) asm {
    emit, 0x0F ; bswap edi
    emit, 0xCF

    mov, eax, edi
    ret
}

define i64 Swap64(i64 Value) asm {
    emit, 0x48 ; bswap rdi
    emit, 0x0F
    emit, 0xCF

    mov, rax, rdi
    ret
}

define void P(i64 V) {
    Print("%x ", (V & 0xFFFF_FFFF))
}

struct SHA1State {
    union {
        struct {
            i32 H0
            i32 H1
            i32 H2
            i32 H3
            i32 H4
        }

        i32[5] H
    }

    i32 ChunkCursor
    i32 Length

    union {
        i8[64] ChunkBytes
        i32[16] ChunkWords
        i32[80] Block
    }

    define void Initialize() {
        this->H0 := 0x67452301
        this->H1 := 0xEFCDAB89 As i32
        this->H2 := 0x98BADCFE As i32
        this->H3 := 0x10325476
        this->H4 := 0xC3D2E1F0 As i32

        this->ChunkCursor := 0
        this->Length := 0
    }

    define void Reset() {
        this->Initialize()
    }

    define i32 LeftShift(i32 Value, i32 Count) {
        return (Value << Count) | (Value >> (32 - Count))
    }

    define void UpdateChunk() {
        this->ChunkCursor := 0

        for (i32 Index := 0, Index < 16, Index++) {
            this->Block[Index] := Swap32(this->ChunkWords[Index])
        }

        for (i32 Index := 16, Index < 80, Index++) {
            i32 Mix := this->Block[Index - 3] ^ this->Block[Index - 8] ^ this->Block[Index - 14] ^ this->Block[Index - 16]

            this->Block[Index] := this->LeftShift(Mix, 1)
        }

        i32 A := this->H0
        i32 B := this->H1
        i32 C := this->H2
        i32 D := this->H3
        i32 E := this->H4

        for (i32 Index := 0, Index < 80, Index++) {
            i32 F := 0
            i32 K := 0

            if (Index < 20) {
                F := (B & C) | ((~B) & D)
                K := 0x5A827999
            }
            else if (Index < 40) {
                F := B ^ C ^ D
                K := 0x6ED9EBA1
            }
            else if (Index < 60) {
                F := (B & C) | (B & D) | (C & D)
                K := 0x8F1BBCDC As i32
            }
            else {
                F := B ^ C ^ D
                K := 0xCA62C1D6 As i32
            }

            i32 Temp := this->LeftShift(A, 5) + F + E + K + this->Block[Index]

            E := D
            D := C
            C := this->LeftShift(B, 30)
            B := A
            A := Temp
        }

        this->H0 += A
        this->H1 += B
        this->H2 += C
        this->H3 += D
        this->H4 += E
    }

    define void Update(void* Data, i32 Size) {
        this->Length += Size

        while (Size != 0) {
            if (this->ChunkCursor) {
                ; We have a partial block to fill

                i8* ChunkBytesTail := this->ChunkBytes + this->ChunkCursor
                i32 SizeToFill := 64 - this->ChunkCursor

                if (Size >= SizeToFill) {
                    ; We have enough inbound data to fill the block completely

                    MoveMemory(ChunkBytesTail, Data, SizeToFill)
                    Size -= SizeToFill
                    Data += SizeToFill

                    this->UpdateChunk()
                }
                else {
                    ; Block will still be partial

                    MoveMemory(ChunkBytesTail, Data, Size)
                    this->ChunkCursor += Size

                    break
                }
            }
            else {
                if (Size >= 64) {
                    ; Enough for a full block of processing

                    MoveMemory(this->ChunkBytes, Data, 64)
                    this->UpdateChunk()

                    Size -= 64
                    Data += 64
                }
                else {
                    ; Leftover, turns into a partial block

                    MoveMemory(this->ChunkBytes, Data, Size)
                    this->ChunkCursor := Size

                    break
                }
            }
        }
    }

    define void UpdateString(i8* String) {
        this->Update(String, StringLength(String))
    }

    define void PadFillCurrentChunk() {
        for (i32 Index := this->ChunkCursor, Index < 64, Index++) {
            this->ChunkBytes[Index] := 0
        }
    }

    define i32 ChunkSpace() {
        return 64 - this->ChunkCursor
    }

    define void Finalize(void* Output) {
        if (this->ChunkSpace() = 0) {
            ; Ensure we have enough space for the 0x80 terminator

            this->UpdateChunk()
        }

        this->Update(i8[0x80], 1)

        if (this->ChunkSpace() < 8) {
            ; Not enough room for length, pad+flush chunk

            this->PadFillCurrentChunk()
            this->UpdateChunk()
        }

        ; Pad to end of chunk for length

        this->PadFillCurrentChunk()
        
        i64 SwappedBitLength := Swap64((this->Length - 1) * 8) ; Exclude 0x80 terminator

        this->ChunkCursor := 56
        this->Update(&SwappedBitLength, 8)

        this->Length -= 9 ; Update to ignore terminator+length

        for (i32 Index := 0, Index < 5, Index++) {
            ; Swap output back to LE

            this->H[Index] := Swap32(this->H[Index])
        }

        MoveMemory(Output, this->H, 20)

        this->Reset()
    }

    define void Hash(void* Data, i32 Size, void* Output) {
        this->Reset()
        this->Update(Data, Size)
        this->Finalize(Output)
    }

    define void Print(i8* Output) {
        for (i32 Index := 0, Index < 5, Index++) {
            for (i32 Byte := 0, Byte < 4, Byte++) {
                i8 Value := Output[(Index * 4) + Byte]

                Print("%B", Value)
            }

            if (Index + 1 != 5) {
                Print(" ")
            }
        }
    }
}

i32 SHA1_BLOCK_SIZE := 64
i32 SHA1_OUTPUT_SIZE := 20

struct SHA1HMACState {
    union {
        i32[16] KeyBlock
        i8[64] KeyBlockBytes
    }

    union {
        i32[16] OPad
        i8[64] OPadBytes
    }

    union {
        i32[16] IPad
        i8[64] IPadBytes
    }

    SHA1State Hasher

    define void Initialize(i8* KeyBytes, i32 KeySize) {
        this~>Hasher->Initialize()

        ZeroMemory(this->KeyBlock, 64)
        ZeroMemory(this->OPad, 64)
        ZeroMemory(this->IPad, 64)

        if (KeySize > SHA1_BLOCK_SIZE) {
            this~>Hasher->Hash(KeyBytes, KeySize, this->KeyBlock)

            KeySize := SHA1_OUTPUT_SIZE
        }
        else {
            MoveMemory(this->KeyBlock, KeyBytes, KeySize)
        }

        MoveMemory(this->OPad, this->KeyBlock, 64)
        MoveMemory(this->IPad, this->KeyBlock, 64)

        for (i32 Index := 0, Index < 64, Index++) {
            this->OPadBytes[Index] ^= 0x5C
            this->IPadBytes[Index] ^= 0x36
        }
    }

    define void Calculate(void* Message, i32 Size, void* Output) {
        SHA1State* Hash := this~>Hasher
        i8[20] Temporary

        Hash->Reset()

        Hash->Update(this->IPad, 64)
        Hash->Update(Message, Size)
        Hash->Finalize(Temporary)

        Hash->Update(this->OPad, 64)
        Hash->Update(Temporary, 20)
        Hash->Finalize(Output)
    }

    define void Print(void* Output) {
        this~>Hasher->Print(Output)
    }
}