#Require "$/Console.rlx"

i64 BIG_NUMBER_BASE := 1000000000 ;0x7FFF_FFFF

enum ComparisonResult {
    Less
    Equal
    Greater
}

#Require "./src/StackTrace.rlx"

BigNumber* FIRST_BIG_NUMBER := null
BigNumber** BIG_NUMBERS_TAIL := null

i32 NEXT_BIG_NUMBER_ID := 0

i32 BIG_NUMBER_CONSTANT_POOL_SIZE := 175
BigNumber** BIG_NUMBER_CONSTANT_POOL := Alloc(BIG_NUMBER_CONSTANT_POOL_SIZE * #void*)

#Require "$/AVLTree.rlx"

AVLTree* BIG_NUMBER_LARGE_CONSTANT_POOL := new AVLTree(#void*) ; <FNV1A(i8*), BigNumber*>

#Require "$/PointerArray.rlx"

struct MillerRabinShortcut {
    BigNumber* Limit
    BigNumber** Bases
    i32 BaseCount
}

PointerArray* MILLER_RABIN_SHORTCUTS := new PointerArray() ; <MillerRabinShortcut*>

enum Primality {
    Prime
    Composite
    NotDefinitelyComposite
}

declare void Walk()

struct BigNumber {
    i32* Digits

    i32 ID
    BigNumber** pThis
    BigNumber* Next

    i32 DigitCount
    i32 DigitCapacity

    i32 ReferenceCount
    i8 Negative
    i8 Constant

    StackTrace AllocationTrace

    define self* Reference() {
        this->ReferenceCount += 1

        return this
    }

    define self* Release() {
        if (this->Constant) {
            return this
        }

        this->ReferenceCount -= 1

        if (this->ReferenceCount < 0) {
            Print("REFERENCE COUNT BELOW ZERO %bn-rd\n", this)
            *null := 0
        }
        else if (this->ReferenceCount = 0) {
            if (this->Next) {
                this->Next->pThis := this->pThis
            }

            *this->pThis := this->Next

            if (BIG_NUMBERS_TAIL = this~>Next) {
                BIG_NUMBERS_TAIL := this->pThis
            }

            Free(this->Digits)
            Free(this)
        }

        return this
    }

    define void Reserve(i32 NewDigitCount) {
        this->DigitCount := NewDigitCount

        if (this->DigitCount <= this->DigitCapacity) {
            return
        }

        this->DigitCapacity := this->DigitCount * 2

        this->Digits := ReAlloc(this->Digits, this->DigitCapacity * 4)
    }

    define void Push(i32 SingleDigit) {
        this->Reserve(this->DigitCount + 1)

        this->Digits[this->DigitCount - 1] := SingleDigit
    }
    define i32 Pop() {
        return this->Digits[--this->DigitCount]
    }

    define void Prepend(i32 SingleDigit) {
        i32 OldDigitCount := this->DigitCount

        this->Reserve(OldDigitCount + 1)
        MoveMemory(&this->Digits[1], &this->Digits[0], OldDigitCount * 4)

        this->Digits[0] := SingleDigit
    }

    static self* Allocate() {
        i32 TraceHeight := CaptureStackTraceHeight()
        self* this := Alloc(#self + (TraceHeight * #StackFrame))

        CaptureStackTrace(this~>AllocationTrace)

        *BIG_NUMBERS_TAIL := this
        this->pThis := BIG_NUMBERS_TAIL

        BIG_NUMBERS_TAIL := this~>Next

        this->ID := NEXT_BIG_NUMBER_ID++

        return this
    }

    static self* WithDigits(i32 DigitCount) {
        self* this := self:Allocate()

        this->DigitCount := DigitCount
        this->Digits := Alloc((DigitCount + 1) * 4)

        return this->Reference()
    }

    static self* New() {
        return self:WithDigits(1)
    }

    static self* New(i64 Value) {
        i8 FitsConstantPool := Value >= 0 && Value < BIG_NUMBER_CONSTANT_POOL_SIZE

        if (FitsConstantPool && BIG_NUMBER_CONSTANT_POOL[Value] != null) {
            return BIG_NUMBER_CONSTANT_POOL[Value]
        }

        self* this := self:Allocate()

        if (FitsConstantPool) {
            BIG_NUMBER_CONSTANT_POOL[Value] := this
            this->Constant := true
        }

        this->Digits := Alloc(4)

        if (Value < 0) {
            this->Negative := true
            Value *= -1
        }

        if (Value = 0) {
            this->Push(0)
        }
        else {
            while (Value != 0) {
                i64 Digit := Value % BIG_NUMBER_BASE

                this->Push(Digit As i32)

                Value /= BIG_NUMBER_BASE
            }
        }

        return this->Reference()
    }

    static BigNumber* Zero() {
        return new self(0)
    }
    static BigNumber* One() {
        return new self(1)
    }
    static BigNumber* Constant(i32 Value) {
        return new self(Value)
    }

    static declare self* New(i8*)

    static BigNumber* LargeConstant(i8* Value) {
        i64 Hash := FNV1A(Value)
        BigNumber* Result := BIG_NUMBER_LARGE_CONSTANT_POOL->GetPointer(Hash)

        if (Result) {
            return Result
        }

        BigNumber* Result := new self(Value)
        Result->Constant := true

        BIG_NUMBER_LARGE_CONSTANT_POOL->InsertPointer(Hash, Result)

        return Result
    }

    static self* New(BigNumber* CloneSource) {
        self* this := self:WithDigits(CloneSource->DigitCount)

        this->Negative := CloneSource->Negative

        MoveMemory(this->Digits, CloneSource->Digits, CloneSource->DigitCount * 4)

        return this
    }

    define self* Shrink() {
        i32 Count := 0

        for (i32 Index := this->DigitCount - 1, Index >= 1, Index--) {
            if (this->Digits[Index] != 0) {
                break
            }

            Count++
        }

        this->Reserve(this->DigitCount - Count)

        return this
    }

    define i32 DigitAt(i32 Index) {
        if (Index >= this->DigitCount) {
            return 0
        }

        return this->Digits[Index]
    }

    static ComparisonResult CompareAbsoluteValue(BigNumber* Left, BigNumber* Right) {
        if (Left->DigitCount > Right->DigitCount) {
            return ComparisonResult::Greater
        }
        else if (Left->DigitCount < Right->DigitCount) {
            return ComparisonResult::Less
        }
        else {
            for (i32 Index := Left->DigitCount - 1, Index >= 0, Index--) {
                i32 L := Left->Digits[Index]
                i32 R := Right->Digits[Index]

                if (L > R) {
                    return ComparisonResult::Greater
                }
                else if (L < R) {
                    return ComparisonResult::Less
                }
            }

            return ComparisonResult::Equal
        }
    }

    static ComparisonResult Compare(BigNumber* Left, BigNumber* Right) {
        Left->Shrink()
        Right->Shrink()

        if (Left->Negative != Right->Negative) {
            if (Left->Negative) {
                return ComparisonResult::Less
            }
            else if (Right->Negative) {
                return ComparisonResult::Greater
            }
        }

        i8 ComparingNegatives := Left->Negative

        ComparisonResult AbsoluteComparison := self:CompareAbsoluteValue(Left, Right)

        ;Print("CompareAbs(%bn-digits, %bn-digits) = %s\n", Left, Right, nameof:(AbsoluteComparison))

        if (AbsoluteComparison = ComparisonResult::Equal) {
            return ComparisonResult::Equal
        }
        else if (AbsoluteComparison = ComparisonResult::Less) {
            ; abs(a) < abs(b)

            if (ComparingNegatives) {
                ; when comparing negatives, the smaller number is greater

                return ComparisonResult::Greater
            }
            else {
                return ComparisonResult::Less
            }
        }
        else if (AbsoluteComparison = ComparisonResult::Greater) {
            ; abs(a) > abs(b)

            if (ComparingNegatives) {
                return ComparisonResult::Less
            }
            else {
                return ComparisonResult::Greater
            }
        }

        return ComparisonResult::Equal
    }

    static BigNumber* Negate(BigNumber* In) {
        BigNumber* Result := new BigNumber(In)

        Result->Negative := !In->Negative

        In->Release()

        return Result
    }
    define BigNumber* Negate() {
        return self:Negate(this)
    }

    define void _Increment(i64 Carry) {
        if (this->Constant) {
            Throw('shit')
        }

        for (i32 Index := 0, Index < this->DigitCount, Index++) {
            i64 Sum := this->Digits[Index] + Carry

            Carry := Sum / BIG_NUMBER_BASE

            this->Digits[Index] := (Sum - (Carry * BIG_NUMBER_BASE)) As i32
        }

        while (Carry != 0) {
            this->Push((Carry % BIG_NUMBER_BASE) As i32)
            Carry /= BIG_NUMBER_BASE
        }
    }

    static BigNumber* BaseAdd(BigNumber* Left, BigNumber* Right) {
        if (Right->DigitCount > Left->DigitCount) {
            BigNumber* Temporary := Left
            Left := Right
            Right := Temporary
        }

        BigNumber* Result := new BigNumber(Left)
        i32 Carry := 0

        for (i32 Index := 0, Index < Right->DigitCount, Index++) {
            i64 L := Left->Digits[Index]
            i64 R := Right->Digits[Index]

            i64 Sum := L + R + Carry

            if (Sum >= BIG_NUMBER_BASE) {
                Carry := 1
                Sum -= BIG_NUMBER_BASE
            }
            else {
                Carry := 0
            }

            Result->Digits[Index] := Sum As i32
        }

        while (Carry != 0 && Index < Left->DigitCount) {
            i64 Sum := Left->Digits[Index] + Carry

            if (Sum >= BIG_NUMBER_BASE) {
                Carry := 1
                Sum -= BIG_NUMBER_BASE
            }
            else {
                Carry := 0
            }

            Result->Digits[Index++] := Sum As i32
        }

        if (Carry) {
            Result->Push(1)
        }

        Left->Release()
        Right->Release()

        return Result
    }

    declare BigNumber* Subtract(BigNumber*)

    static BigNumber* Add(BigNumber* Left, BigNumber* Right) {
        if (Left->Negative != Right->Negative) {
            return Left->Subtract(Right->Negate())
        }

        return BigNumber:BaseAdd(Left, Right)
    }
    define BigNumber* Add(BigNumber* Right) {
        return self:Add(this, Right)
    }

    define void _Decrement(i64 Value) {
        if (this->Constant) {
            Throw('shit2')
        }

        i32 Borrow := 0
        i64 Carry := -Value

        for (i32 Index := 0, Index < this->DigitCount, Index++) {
            i64 Difference := this->Digits[Index] + Carry

            Carry := Difference / BIG_NUMBER_BASE
            Difference %= BIG_NUMBER_BASE

            if (Difference < 0) {
                this->Digits[Index] := (Difference + BIG_NUMBER_BASE) As i32
                Carry -= 1
            }
            else {
                this->Digits[Index] := Difference As i32
            }
        }
        
        this->Shrink()
    }

    static BigNumber* BaseSubtract(BigNumber* Left, BigNumber* Right, BigNumber* Result) {
        i64 Borrow := 0

        for (i32 Index := 0, Index < Right->DigitCount, Index++) {
            i64 L := Left->Digits[Index]
            i64 R := Right->Digits[Index]

            i64 Difference := L - Borrow - R

            if (Difference < 0) {
                Difference += BIG_NUMBER_BASE
                Borrow := 1
            }
            else {
                Borrow := 0
            }

            Result->Digits[Index] := Difference As i32
        }

        for (Index := Right->DigitCount, Index < Left->DigitCount, Index++) {
            i64 Difference := Left->Digits[Index] - Borrow

            if (Difference < 0) {
                Difference += BIG_NUMBER_BASE
            }
            else {
                Result->Digits[Index++] := Difference As i32
                break
            }

            Result->Digits[Index] := Difference As i32
        }

        while (Index < Left->DigitCount) {
            Result->Digits[Index] := Left->Digits[Index]
            Index++
        }

        Left->Release()
        Right->Release()

        return Result->Shrink()
    }

    static BigNumber* BaseSubtract(BigNumber* Left, BigNumber* Right) {
        BigNumber* Result := new BigNumber(Left)
        
        return self:BaseSubtract(Left, Right, Result)
    }

    static BigNumber* Subtract(BigNumber* Left, BigNumber* Right) {
        if (Left->Negative != Right->Negative) {
            return Left->Add(Right->Negate())
        }

        ComparisonResult Comparison := BigNumber:CompareAbsoluteValue(Left, Right)

        if (Comparison = ComparisonResult::Equal || Comparison = ComparisonResult::Greater) {
            return self:BaseSubtract(Left, Right)
        }
        else {
            BigNumber* Result := self:BaseSubtract(Right, Left)
            Result->Negative := !Left->Negative
            return Result
        }
    }

    define BigNumber* Subtract(BigNumber* Right) {
        return self:Subtract(this, Right)
    }

    static BigNumber* AbsoluteValue(BigNumber* In) {
        BigNumber* Result := new BigNumber(In)

        Result->Negative := false
        In->Release()

        return Result
    }
    define BigNumber* AbsoluteValue() {
        return self:AbsoluteValue(this)
    }

    static BigNumber* MultiplyBySingleDigit(BigNumber* Left, i64 Right) {
        BigNumber* Result := self:WithDigits(Left->DigitCount + 1)

        i64 Carry := 0

        for (i32 Index := 0, Index < Left->DigitCount, Index++) {
            i64 Product := (Left->Digits[Index] * Right) + Carry

            Carry := Product / BIG_NUMBER_BASE

            Result->Digits[Index] := (Product - (Carry * BIG_NUMBER_BASE)) As i32
        }

        while (Carry) {
            Result->Digits[Index++] := (Carry % BIG_NUMBER_BASE) As i32
            Carry /= BIG_NUMBER_BASE
        }

        return Result->Shrink()
    }


    static BigNumber* BaseMultiply(BigNumber* Left, BigNumber* Right) {
        BigNumber* Result := self:WithDigits(Left->DigitCount + Right->DigitCount)

        i64 Carry := 0

        for (i32 OuterIndex := 0, OuterIndex < Left->DigitCount, OuterIndex++) {
            i64 OuterDigit := Left->Digits[OuterIndex]

            for (i32 InnerIndex := 0, InnerIndex < Right->DigitCount, InnerIndex++) {
                i64 InnerDigit := Right->Digits[InnerIndex]

                i64 Product := (OuterDigit * InnerDigit) + Result->Digits[OuterIndex + InnerIndex]

                Carry := Product / BIG_NUMBER_BASE

                Result->Digits[OuterIndex + InnerIndex] := (Product - (Carry * BIG_NUMBER_BASE)) As i32
                Result->Digits[OuterIndex + InnerIndex + 1] += Carry As i32
            }
        }

        return Result->Shrink()
    }

    static BigNumber* Multiply(BigNumber* Left, BigNumber* Right) {
        i8 Negative := Left->Negative + Right->Negative = 1

        BigNumber* Result := null

        if (Left->DigitCount = 1) {
            Result := self:MultiplyBySingleDigit(Right, Left->Digits[0])
        }
        else if (Right->DigitCount = 1) {
            Result := self:MultiplyBySingleDigit(Left, Right->Digits[0])
        }
        else {
            Result := self:BaseMultiply(Left, Right)
        }

        Result->Negative := Negative

        Left->Release()
        Right->Release()

        return Result
    }
    define BigNumber* Multiply(BigNumber* Right) {
        return self:Multiply(this, Right)
    }

    define i8 Equals(i64 Value) {
        this->Shrink()

        if (Value = 0 && this->DigitCount = 1) {
            return this->Digits[0] = 0
        }

        i32 Index := 0

        while (Value != 0) {
            i64 Digit := Value % BIG_NUMBER_BASE

            if (Digit != this->Digits[Index++]) {
                return false
            }

            Value /= BIG_NUMBER_BASE
        }

        return Index = this->DigitCount
    }
    define i8 Equals(BigNumber* Other) {
        return self:Compare(this, Other) = ComparisonResult::Equal
    }

    define i8 IsOdd() {
        return (this->Digits[0] & 1) As i8
    }
    define i8 IsEven() {
        return !this->IsOdd()
    }

    define i8 IsZero() {
        return this->Equals(0)
    }
    define i8 IsNotZero() {
        return !this->IsZero()
    }

    define i8 IsLessThan(BigNumber* Other) {
        return self:Compare(this, Other) = ComparisonResult::Less
    }
    define i8 IsLessThanOrEqualTo(BigNumber* Other) {
        ComparisonResult Result := self:Compare(this, Other)

        return Result = ComparisonResult::Less || Result = ComparisonResult::Equal
    }

    define i8 IsGreaterThan(BigNumber* Other) {
        return self:Compare(this, Other) = ComparisonResult::Greater
    }
    define i8 IsGreaterThanOrEqualTo(BigNumber* Other) {
        ComparisonResult Result := self:Compare(this, Other)

        return Result = ComparisonResult::Greater || Result = ComparisonResult::Equal
    }

    static BigNumber* DivideBySingleDigit(BigNumber* Dividend, i64 Divisor, BigNumber** OutRemainder) {
        BigNumber* Quotient := new BigNumber(Dividend)

        i64 Carry := 0
        i64 Remainder := 0

        for (i32 Index := Dividend->DigitCount - 1, Index >= 0, Index--) {
            i64 Digit := Dividend->Digits[Index]

            i64 InnerDivisor := (Remainder * BIG_NUMBER_BASE) + Digit
            i64 InnerQuotient := InnerDivisor / Divisor

            Remainder := InnerDivisor - InnerQuotient * Divisor

            Quotient->Digits[Index] := InnerQuotient As i32
        }

        *OutRemainder := new BigNumber(Remainder)

        return Quotient->Shrink()
    }

    static BigNumber* DivideByGuessCheck(BigNumber* Dividend, BigNumber* Denominator, BigNumber** OutRemainder) {
        BigNumber* Result := BigNumber:WithDigits(0)
        BigNumber* Part := BigNumber:WithDigits(0)

        i32 DividendLength := Dividend->DigitCount

        i64 DivisorHigh := Denominator->Digits[Denominator->DigitCount - 1] * BIG_NUMBER_BASE
        DivisorHigh += Denominator->Digits[Denominator->DigitCount - 2]

        while (DividendLength) {
            Part->Prepend(Dividend->Digits[--DividendLength])

            Part->Shrink()

            if (Part->IsLessThan(Denominator)) {
                Result->Push(0)
                continue
            }

            i32 PartLength := Part->DigitCount
            i64 PartHigh := Part->Digits[PartLength - 1] * BIG_NUMBER_BASE

            if (PartLength >= 2) {
                PartHigh += Part->Digits[PartLength - 2]
            }

            if (PartLength > Denominator->DigitCount) {
                PartHigh := (PartHigh + 1) * BIG_NUMBER_BASE
            }

            i64 Guess := PartHigh / DivisorHigh

            loop {
                BigNumber* Check := self:MultiplyBySingleDigit(Denominator, Guess)

                if (Check->IsLessThanOrEqualTo(Part)) {
                    break
                }

                if (--Guess = 0) {
                    break
                }

                Check->Release()
            }

            Result->Push(Guess As i32)
            Part := Part->Subtract(Check)
        }

        BigNumber* ActualResult := BigNumber:WithDigits(Result->DigitCount)

        for (i32 Index := 0, Index < Result->DigitCount, Index++) {
            ActualResult->Digits[Index] := Result->Digits[Result->DigitCount - Index - 1]
        }

        Result->Release()

        *OutRemainder := Part->Shrink()

        return ActualResult->Shrink()
    }

    static BigNumber* DivideBySubtract(BigNumber* Numerator, BigNumber* Denominator, BigNumber** OutRemainder) {
        BigNumber* Quotient := new BigNumber()
        BigNumber* Remainder := new BigNumber(Numerator)

        while (Remainder->IsGreaterThanOrEqualTo(Denominator)) {
            ;Print("%bn-digits - %bn-digits = ", Remainder, Denominator)
            self:BaseSubtract(Remainder->Reference(), Denominator->Reference(), Remainder)
            ;Print("%bn-digits\n", Remainder)
            Quotient->_Increment(1)
        }

        *OutRemainder := Remainder->Shrink()
        return Quotient->Shrink()
    }

    static BigNumber* LongDivide(BigNumber* Numerator, BigNumber* Denominator, BigNumber** OutRemainder) {
        BigNumber* Quotient := BigNumber:WithDigits(Numerator->DigitCount)
        BigNumber* Remainder := new BigNumber(Numerator)

        BigNumber* Part := BigNumber:WithDigits(0)    

        for (i32 Index := Remainder->DigitCount - 1, Index >= 0, Index--) {
            ;Print("%i\n", Index)
            Part->Prepend(Remainder->Pop())

            ;Print("[%i:%i]: %bn-rd\n", Index + Part->DigitCount, Part->DigitCount, Part)

            if (Part->IsGreaterThanOrEqualTo(Denominator)) {
                ;Print("%bn-rd >= %bn-rd\n", Part, Denominator)

                Part->Shrink()

                BigNumber* PartialRemainder := null
                BigNumber* PartialQuotient := self:DivideByGuessCheck(Part, Denominator, &PartialRemainder)

                ;Print("%bn-rd / %bn-rd = %bn-rd (R %bn-rd)\n", Part, Denominator, PartialQuotient, PartialRemainder)

                ;Print("Overall remainder before: %bn-rd\n", Remainder)

                for (i32 CopyIndex := 0, CopyIndex < PartialRemainder->DigitCount, CopyIndex++) {
                    Remainder->Digits[Index + CopyIndex] := PartialRemainder->Digits[CopyIndex]
                }

                Remainder->DigitCount := Index + CopyIndex

                ;Print("Overall remainder after: %bn-rd\n", Remainder)
                ;Print("Rem %bn-rd\n", Remainder)

                ;Print("Overall quotient before: %bn-rd\n", Quotient)

                for (i32 CopyIndex := 0, CopyIndex < PartialQuotient->DigitCount, CopyIndex++) {
                    Quotient->Digits[Index + CopyIndex] := PartialQuotient->Digits[CopyIndex]
                    ;Print("%i [%i] := %i\n", Index, Index + CopyIndex, PartialQuotient->Digits[CopyIndex])
                }

                ;Print("Overall quotient after: %bn-rd\n", Quotient)

                ;Print("%bn-rd\n", Quotient)
                                
                Part->DigitCount := 0

                Index := Remainder->DigitCount

                PartialQuotient->Release()
                PartialRemainder->Release()
            }
        }

        Remainder->Release()
        Remainder := Part

        ;Print("Rem %bn-rd\n", Remainder)

        ;Print("Rem %bn-rd\n", Remainder)

        ;Print("%bn-rd / %bn-rd = %bn-rd (R %bn-rd)\n", Numerator, Denominator, Quotient, Remainder)

        *OutRemainder := Remainder->Shrink()

        return Quotient->Shrink()
    }

    static BigNumber* Divide(BigNumber* Numerator, BigNumber* Denominator, BigNumber** OutRemainder) {
        ComparisonResult Comparison := self:CompareAbsoluteValue(Numerator, Denominator)

        if (Comparison = ComparisonResult::Equal) {
            Numerator->Release()
            Denominator->Release()

            *OutRemainder := new BigNumber(0)

            if (Numerator->Negative != Denominator->Negative) {
                return new BigNumber(-1)
            }
            else {
                return new BigNumber(1)
            }
        }
        else if (Comparison = ComparisonResult::Less) {
            Denominator->Release()
            *OutRemainder := Numerator

            return new BigNumber(0)
        }

        BigNumber* Result := null

        if (Denominator->Shrink()->DigitCount = 1) {
            Result := self:DivideBySingleDigit(Numerator, Denominator->Digits[0], OutRemainder)
        }
        else {
            Result := self:LongDivide(Numerator, Denominator, OutRemainder)
        }

        Numerator->Release()
        Denominator->Release()

        return Result
    }
    
    define BigNumber* Divide(BigNumber* Denominator, BigNumber** OutRemainder) {
        return self:Divide(this, Denominator, OutRemainder)
    }

    define BigNumber* Quotient(BigNumber* Denominator) {
        BigNumber* Remainder := null
        BigNumber* Quotient := this->Divide(Denominator, &Remainder)
        Remainder->Release()

        return Quotient
    }

    define BigNumber* Remainder(BigNumber* Denominator) {
        BigNumber* Remainder := null
        this->Divide(Denominator, &Remainder)->Release()

        return Remainder
    }
    define BigNumber* Modulo(BigNumber* Denominator) {
        return this->Remainder(Denominator)
    }

    define i8 DivisibleBy(BigNumber* Factor) {
        BigNumber* Remainder := this->Reference()->Remainder(Factor->Reference())
        i8 Result := Remainder->IsZero()
        Remainder->Release()

        return Result
    }

    static BigNumber* New(i8* String, i32 Length, i32 RawBase) {
        BigNumber* Base := new BigNumber(RawBase)
        BigNumber* Result := new BigNumber(0)

        if (String[0] = '-') {
            Result->Negative := true

            String += 1
            Length -= 1
        }

        for (i32 Index := 0, Index < Length, Index++) {
            i8 Next := Lower(String[Index])

            if (Next = '_' || Next = ',') {
                continue
            }

            if !(IsNumeric(Next, RawBase)) {
                Result->Release()
                Result := null

                break
            }

            Result := Result->Multiply(Base->Reference())
            Result := Result->Add(new BigNumber(GetCharacterValue(Next)))
        }

        Base->Release()

        return Result
    }
    static BigNumber* New(i8* String, i32 RawBase) {
        return self:New(String, StringLength(String), RawBase)
    }
    static BigNumber* New(i8* String) {
        return self:New(String, 10)
    }

    static BigNumber* Square(BigNumber* In) {
        BigNumber* Result := self:WithDigits(In->DigitCount * 2)

        i64 Carry := 0

        for (i32 Index := 0, Index < In->DigitCount, Index++) {
            i64 Digit := In->Digits[Index]

            for (i32 InnerIndex := 0, InnerIndex < In->DigitCount, InnerIndex++) {
                i64 InnerDigit := In->Digits[InnerIndex]

                i64 Product := (Digit * InnerDigit) + Result->Digits[Index + InnerIndex]

                Carry := Product / BIG_NUMBER_BASE

                Result->Digits[Index + InnerIndex] := (Product - (Carry * BIG_NUMBER_BASE)) As i32
                Result->Digits[Index + InnerIndex + 1] += Carry As i32
            }
        }

        In->Release()

        return Result->Shrink()
    }

    define BigNumber* Square() {
        return self:Square(this)
    }

    define BigNumber* Power(i32 Exponent) {
        BigNumber* Result := self:One()
        BigNumber* Base := this->Reference()

        while (Exponent > 0) {
            if (Exponent & 1) {
                Result := Result->Multiply(Base->Reference())
            }

            Base := Base->Square()
            Exponent /= 2
        }

        Base->Release()

        return Result
    }

    static BigNumber* PowerModulo(BigNumber* Base, BigNumber* Exponent, BigNumber* Modulus) {
        BigNumber* Result := self:One()
        
        ;Base := Base->Remainder(Modulus->Reference())

        while (Exponent->IsGreaterThan(self:Zero())) {
            ;Print("Before: %bn-rd %bn-rd %bn-rd\n", Base, Exponent, Result)

            if (Exponent->IsOdd()) {
                Result := Result->Multiply(Base->Reference())->Modulo(Modulus->Reference())

                ;Print("E & 1: %bn-rd\n", Result)
            }

            Base := Base->Square()->Modulo(Modulus->Reference())
            Exponent := Exponent->Quotient(self:Constant(2))

            ;Print("After: %bn-rd %bn-rd\n", Base, Exponent)
        }

        Base->Release()
        Exponent->Release()
        Modulus->Release()

        return Result
    }

    static BigNumber* Power(BigNumber* Base, BigNumber* RawExponent) {
        BigNumber* Result := self:One()
        BigNumber* Exponent := new BigNumber(RawExponent)

        while (Exponent->IsGreaterThan(self:Zero())) {
            Result := Result->Multiply(Base->Reference())
            Exponent->_Decrement(1)
        }

        Base->Release()
        Exponent->Release()
        RawExponent->Release()

        return Result
    }

    define BigNumber* Power(BigNumber* Exponent) {
        return self:Power(this, Exponent)
    }

    static BigNumber* Logarithm(BigNumber* N, BigNumber* Base) {
        BigNumber* Result := new BigNumber(self:One())
        BigNumber* Current := Base->Reference()

        while (N->IsGreaterThanOrEqualTo(Current)) {
            Current := Current->Multiply(Base->Reference())
            Result->_Increment(1)
        }

        Current->Release()
        N->Release()
        Base->Release()

        return Result
    }

    define BigNumber* Logarithm(BigNumber* Base) {
        return self:Logarithm(this, Base)
    }

    static Primality IsBasicPrime(BigNumber* In) {
        In->Shrink()

        if (In->DigitCount = 1) {
            i32 Single := In->Digits[0]

            if (Single = 1) {
                return Primality::Composite
            }
            else if (Single = 2 || Single = 3 || Single = 5) {
                return Primality::Prime
            }
        }

        if (In->IsEven()) {
            return Primality::Composite
        }

        if (In->DivisibleBy(self:Constant(3)) || In->DivisibleBy(self:Constant(5))) {
            return Primality::Composite
        }

        if (In->IsLessThan(self:Constant(49))) {
            return Primality::Prime
        }

        return Primality::NotDefinitelyComposite
    }

    static i8 MillerRabinTest(BigNumber* N, BigNumber** Bases, i32 BaseCount) {
        BigNumber* MinusOne := N->Reference()->Subtract(self:Constant(1))

        ;Print("N: %bn-rd, N - 1: %bn-rd\n", N, MinusOne)

        BigNumber* B := MinusOne->Reference()
        i32 R := 0

        while (B->IsEven()) {
            B := B->Quotient(self:Constant(2))
            R++
        }

        ;Print("B: %bn-rd, R: %i\n", B, R)

        for (i32 Index := 0, Index < BaseCount, Index++) {
            BigNumber* Base := Bases[Index]

            Print("\nCheck N: %bn-rd, Base: %bn-rd\n", N, Base)

            if (N->IsLessThan(Base)) {
                continue
            }

            Print("pow(%bn-rd, %bn-rd, %bn-rd) ", Base, B, N)

            BigNumber* X := self:PowerModulo(Base->Reference(), B->Reference(), N->Reference())

            Print("= %bn-rd\n", X)

            if (X->Equals(1) || X->Equals(MinusOne)) {
                Print(" = 1 or N-1\n")

                X->Release()

                continue
            }

            i8 XEqualsMinusOne := false

            for (i32 D := R - 1, D != 0, D--) {
                Print("pow(%bn-rd, 2, %bn-rd) = ", X, N)
                X := X->Square()->Modulo(N->Reference())
                Print("bn-rd\n", X)

                if (X->Equals(1)) {
                    X->Release()
                    B->Release()
                    MinusOne->Release()

                    return false
                }

                if (X->Equals(MinusOne)) {
                    XEqualsMinusOne := true
                    break
                }
            }

            X->Release()

            if (XEqualsMinusOne) {
                continue
            }

            B->Release()
            MinusOne->Release()

            return false
        }

        B->Release()
        MinusOne->Release()

        return true
    }

    static i8 DeterministicMillerRabinTest(BigNumber* N) {
        BigNumber* BitCount := N->Reference()->Logarithm(self:Constant(2))->Add(self:One())
        BigNumber* BitCountLogN := BitCount->Quotient(self:Constant(3))

        BigNumber* Limit := BitCountLogN->Square()->Multiply(self:Constant(2))

        Print("%bn-base-10 miller rabin limit: %bn-base-10\n", N, Limit)

        if (Limit->Shrink()->DigitCount != 1) {
            Print("PANIC!!! MILLER RABIN SUX!!!!!\n")
            *null := 0
        }

        i32 BaseCount := Limit->Digits[0]
        BigNumber** Bases := Alloc(BaseCount * #BigNumber*)

        Limit->Release()

        for (i32 Index := 0, Index < BaseCount, Index++) {
            Bases[Index] := new BigNumber(Index + 2)
        }

        i8 Result := self:MillerRabinTest(N, Bases, BaseCount)

        for (i32 Index := 0, Index < BaseCount, Index++) {
            Bases[Index]->Release()
        }

        Free(Bases)

        return Result
    }

    static void DefineMillerRabinShortcut(i8* Limit, i32* Bases) {
        MillerRabinShortcut* Shortcut := Alloc(#MillerRabinShortcut)

        for (i32 BaseCount := 0, Bases[BaseCount] != 0, BaseCount++) {}

        Shortcut->Limit := self:LargeConstant(Limit)
        Shortcut->BaseCount := BaseCount
        Shortcut->Bases := Alloc(BaseCount * #BigNumber*)

        for (i32 Index := 0, Index < BaseCount, Index++) {
            BigNumber* Base := new self(Bases[Index])
            Base->Constant := true

            Shortcut->Bases[Index] := Base
        }

        MILLER_RABIN_SHORTCUTS->Push(Shortcut)
    }

    static void InitializeMillerRabinShortcuts() {
        self:DefineMillerRabinShortcut("2047", i32[2, 0])
        self:DefineMillerRabinShortcut("1,373,653", i32[2, 3, 0])
        self:DefineMillerRabinShortcut("9,080,191", i32[31, 73, 0])
        self:DefineMillerRabinShortcut("25,326,001", i32[2, 3, 5, 0])
        self:DefineMillerRabinShortcut("3,215,031,751", i32[2, 3, 5, 7, 0])
        self:DefineMillerRabinShortcut("4,759,123,141", i32[2, 7, 61, 0])
        self:DefineMillerRabinShortcut("1,122,004,669,633", i32[2, 13, 23, 1662803, 0])
        self:DefineMillerRabinShortcut("2,152,302,898,747", i32[2, 3, 5, 7, 11, 0])
        self:DefineMillerRabinShortcut("3,474,749,660,383", i32[2, 3, 5, 7, 11, 13, 0])
        self:DefineMillerRabinShortcut("341,550,071,728,321", i32[2, 3, 5, 7, 11, 13, 17, 0])
        self:DefineMillerRabinShortcut("3,825,123,056,546,413,051", i32[2, 3, 5, 7, 11, 13, 17, 19, 23, 0])
        self:DefineMillerRabinShortcut("318,665,857,834,031,151,167,461", i32[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 0])
        self:DefineMillerRabinShortcut("3,317,044,064,679,887,385,961,981", i32[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 0])
    }

    static Primality IsPrimeShortcut(BigNumber* N) {
        i8 Confident := true
        MillerRabinShortcut* BestShortcut := null

        i32 Count := MILLER_RABIN_SHORTCUTS->Count()

        for (i32 Index := 0, Index < Count, Index++) {
            MillerRabinShortcut* Shortcut := MILLER_RABIN_SHORTCUTS->At(Index)

            if (N->IsLessThan(Shortcut->Limit)) {
                BestShortcut := Shortcut
                break
            }
        }

        if (BestShortcut = null) {
            BestShortcut := MILLER_RABIN_SHORTCUTS->At(Count - 1)
            Confident := false
        }

        if (self:MillerRabinTest(N, BestShortcut->Bases, BestShortcut->BaseCount)) {
            if (Confident) {
                return Primality::Prime
            }
            else {
                return Primality::NotDefinitelyComposite
            }
        }

        return Primality::Composite
    }

    static i8 IsPrime(BigNumber* N) {
        Primality Basic := self:IsBasicPrime(N)

        if (Basic = Primality::Prime) {
            return true
        }
        else if (Basic = Primality::Composite) {
            return false
        }

        Primality Shortcut := self:IsPrimeShortcut(N)

        if (Shortcut = Primality::Prime) {
            return true
        }
        else if (Shortcut = Primality::Composite) {
            return false
        }

        if (self:DeterministicMillerRabinTest(N)) {
            return true
        }

        return false
    }

    static i8 Initialize() {
        FIRST_BIG_NUMBER := null
        BIG_NUMBERS_TAIL := &FIRST_BIG_NUMBER

        for (i32 Index := 0, Index < BIG_NUMBER_CONSTANT_POOL_SIZE, Index++) {
            BIG_NUMBER_CONSTANT_POOL[Index] := new BigNumber(Index)
        }

        self:InitializeMillerRabinShortcuts()

        /*for (i32 Index := 0, Index < MILLER_RABIN_SHORTCUTS_COUNT, Index++) {
            BigNumberMillerRabinShortcut* Shortcut := MILLER_RABIN_SHORTCUTS[Index]

            Shortcut->Value := new BigNumber(Shortcut->RawValue)
            Shortcut->Value->Constant := true

            i32 BaseCount := 0

            for (i32 InnerIndex := 0, Shortcut->RawBases[InnerIndex] != 0, InnerIndex++) {
                BaseCount++
            }

            Shortcut->Bases := Alloc(BaseCount * #BigNumber*)

            for (i32 InnerIndex := 0, InnerIndex < BaseCount, InnerIndex++) {
                Shortcut->Bases[InnerIndex] := new BigNumber(Shortcut->RawBases[InnerIndex])
            }
        }*/

        return true
    }
}

i8 BIG_NUMBER_INITIALIZED := BigNumber:Initialize()

define void Walk() {
    BigNumber* Current := FIRST_BIG_NUMBER

    while (Current != null) {
        Print("#%i: %bn-rd\n", Current->ID, Current)

        Current := Current->Next
    }
}

define i8 HadLeaks() {
    BigNumber* Current := FIRST_BIG_NUMBER

    while (Current != null) {
        if (!Current->Constant) {
            Print("BN #%i was leaked with refcount %i, allocated at:\n", Current->ID, Current->ReferenceCount)
            Current->AllocationTrace->Print()
        }

        ;Print("%x %x\n", Current, Current->Next)

        Current := Current->Next
    }

    return false
}

#Require "./src/Big/Print.rlx"

