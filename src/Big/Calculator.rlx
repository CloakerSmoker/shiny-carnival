
#Require "$/Memory.rlx"
#Require "$/PointerArray.rlx"
#Require "$/String.rlx"

#Require "./src/Big/Big.rlx"

enum TokenType {
    Identifier
    Punctuation
    Operator
    Number
}

enum Punctuation {
    OpenParenthesis := '('
    CloseParenthesis := ')'
}

enum Operator {
    Plus := '+',
    Minus := '-',
    Times := '*',
    Divide := '/',
    Remainder := '%',
    Power := '^'
}

struct Token {
    TokenType Type

    union {
        struct {
            Punctuation PunctuationValue
        }
        struct {
            Operator OperatorValue
        }
        struct {
            i8* IdentifierValue
        }
        struct {
            BigInteger* NumberValue
        }
    }

    static self* New(TokenType Type) {
        self* this := Alloc(#self)
        this->Type := Type
        return this
    }

    static self* New(i8* Identifier) {
        self* this := new self(TokenType::Identifier)
        this->IdentifierValue := Identifier
        return this
    }

    static self* New(Punctuation P) {
        self* this := new self(TokenType::Punctuation)
        this->PunctuationValue := P
        return this
    }

    static self* New(Operator O) {
        self* this := new self(TokenType::Operator)
        this->OperatorValue := O
        return this
    }

    static self* New(BigInteger* N) {
        self* this := new self(TokenType::Number)
        this->NumberValue := N
        return this
    }

    define i8 Is(TokenType Type) {
        return this->Type = Type
    }
    define i8 Is(Punctuation P) {
        return this->Type = TokenType::Punctuation && this->PunctuationValue = P
    }
    define i8 Is(Operator O) {
        return this->Type = TokenType::Operand && this->OperatorValue = O
    }
}

define PointerArray* Tokenize(i8* Source, i32 SourceLength) {
    PointerArray* Tokens := new PointerArray() ; <Token*>

    for (i32 Index := 0, Index < SourceLength, Index++) {
        i8 Next := Source[Index]

        if (IsWhiteSpace(Next)) {
            continue
        }
        else if (nameof:(Next As Punctuation) != null) {
            Tokens->Push(new Token(Next As Punctuation))
        }
        else if (nameof:(Next As Operator) != null) {
            Tokens->Push(new Token(Next As Operator))
        }
        else if (IsNumeric(Next)) {
            i32 Base := 10

            if (Next = '0') {
                i8 Peek := Source[++Index]

                if (Peek = 'b') {
                    Base := 2
                }
                else if (Peek = 'o') {
                    Base := 8
                }
                else if (Peek = 'x') {
                    Base := 16
                }
                else {
                    Index--
                }
            }

            i32 Start := Index

            while (IsNumeric(Next, Base) || Next = '_' || Next = ',') {
                Next := Source[++Index]
            }

            i32 Length := Index - Start
            BigInteger* Value := new BigInteger(Source + Start, Length, Base)

            Tokens->Push(new Token(Value))
        }
        else if (IsAlpha(Next)) {
            i32 Start := Index

            while (IsAlphaNumeric(Next)) {
                Next := Source[++Index]
            }

            i32 Length := Index - Start - 1

            i8* Identifier := Alloc(Length + 1)
            MoveMemory(Identifier, Source + Start, Length)

            Tokens->Push(new Token(Identifier))
        }
    }

    return Tokens
}

enum ExpressionType {
    Variable
    Number
    PrefixUnary
    SuffixUnary
    Binary
}

define i32 GetPrefixPrecedence(Operator O) {
    if (O = Operator)
}

struct Expression {
    ExpressionType Type

    union {
        Token* VariableName
        BigInteger* NumberValue

        struct {
            Token* UnaryOperator
            Expression* Operand
        }

        struct {
            Token* BinaryOperator
            Expression* Left
            Expression* Right
        }
    }

    static self* New(ExpressionType Type) {
        self* this := Alloc(#self)
        this->Type := Type
        return this
    }

    static self* New(Token* VariableName) {
        self* this := new self(ExpressionType::Variable)
        this->VariableName := VariableName
        return this
    }
    static self* New(BigInteger* Number) {
        self* this := new self(ExpressionType::Number)
        this->NumberValue := Number
        return this
    }
    static self* New(Token* UnaryOperator, Expression* Operand) {
        self* this := new self(ExpressionType::PrefixUnary)
        this->UnaryOperator := UnaryOperator
        this->Operand := Operand
        return this
    }
    static self* New(Expression* Operand, Token* UnaryOperator) {
        self* this := new self(ExpressionType::SuffixUnary)
        tihs->Operand := Operand
        tihs->UnaryOperator := UnaryOperator
        return this
    }
    static self* New(Expression* Left, Token* BinaryOperator, Expression* Right) {
        self* this := new self(ExpressionType::Binary)
        this->Left := Left
        this->BinaryOperator := Binary
        this->Right := Right
        return this
    }
}

struct Parser {

    PointerArray* Tokens
    i32 Index

    define void Expect(TokenType Type) {

    }
    define void Expect(Punctuation P) {

    }

    define Expression* ParseOperand() {
        Token* Next := this->GetNextToken()

        if (Next->Is(TokenType::Number)) {
            return new Expression(Next->NumberValue)
        }
        else if (Next->Is(Punctuation::OpenParenthesis)) {
            Expression* Result := this->ParseExpresion()

            this->Expect(Punctuation::CloseParenthesis)

            return Result
        }
        else if (Next->Is(TokenType::Operator)) {

        }
    }

    define Expression* ParseExpresion(i32 Precedence) {
        Expression* Left := this->ParseOperand()
    }
    
    define Expression* ParseExpresion() {

    }
}

define i32 Main(i64 ArgC, i8** ArgV) {
    i8* Source := "1 + 2 * 3"
    i32 Length := StringLength(Source)

    PointerArray* Tokens := Tokenize(Source, Length)
    i32 Count := Tokens->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        Token* T := Tokens->At(Index)

        Print("%s: ", nameof:(T->Type))

        if (T->Type = TokenType::Identifier) {
            Print("%s\n", T->IdentifierValue)
        }
        else if (T->Type = TokenType::Punctuation) {
            Print("%s\n", nameof:(T->PunctuationValue))
        }
        else if (T->Type = TokenType::Operator) {
            Print("%s\n", nameof:(T->OperatorValue))
        }
        else if (T->Type = TokenType::Number) {
            Print("%bn-base-10\n", T->NumberValue)
        }
    }

    return 0
}